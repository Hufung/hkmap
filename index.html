<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hong Kong Finder</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet.js CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
     
    <!-- Leaflet.js JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>

    <!-- Leaflet Routing Machine CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    
    <!-- Leaflet Routing Machine JS -->
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

    <!-- JSZip for KMZ handling -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
     
    <style>
        /* Set map height */
        #map { 
            height: 100vh; 
            width: 100%;
            /* Ensure map is behind overlays */
            z-index: 10;
        }
        
        /* Custom Leaflet Icon Style for Car Parks */
        .carpark-icon {
            background-color: #007BFF;
            color: white;
            font-weight: bold;
            font-size: 14px;
            font-family: Arial, sans-serif;
            border: 2px solid #FFFFFF;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            cursor: pointer;
        }

        /* Custom Leaflet Icon Style for Attractions (Mountain SVG) */
        .mountain-icon {
            background-color: #22c55e; /* green-500 */
            border: 2px solid #FFFFFF;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            cursor: pointer;
        }
        .mountain-icon svg {
            width: 18px;
            height: 18px;
            fill: white;
        }

        /* Custom Leaflet Icon Style for Viewing Points (Viewer SVG) */
        .viewer-icon {
            background-color: #f59e0b; /* yellow-500 */
            border: 2px solid #FFFFFF;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            cursor: pointer;
        }
        .viewer-icon svg {
            width: 18px;
            height: 18px;
            fill: white;
        }
        
        /* Custom Leaflet Icon Style for Parking Meters (Car SVG) */
        .parking-meter-icon {
            background-color: #8b5cf6; /* purple-500 */
            border: 2px solid #FFFFFF;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            cursor: pointer;
        }
        .parking-meter-icon svg {
            width: 18px;
            height: 18px;
            fill: white;
        }

        /* Custom Leaflet Icon Style for Roundabouts */
        .roundabout-icon {
            background-color: #ff6b6b; /* red-400 */
            color: white;
            font-weight: bold;
            font-size: 14px;
            font-family: Arial, sans-serif;
            border: 2px solid #FFFFFF;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            cursor: pointer;
        }

        /* Language Switcher Styles */
        .lang-btn.active {
            background-color: #007BFF;
            color: white;
        }
        .lang-btn:not(.active) {
            background-color: #f3f4f6; /* Tailwind gray-100 */
            color: #374151; /* Tailwind gray-700 */
        }
        .lang-btn:not(.active):hover {
            background-color: #e5e7eb; /* Tailwind gray-200 */
        }

        /* Layer Control Styles */
        #layer-control {
            top: 1rem; /* 16px */
            left: 1rem; /* 16px */
            z-index: 1000;
            background-color: white;
            padding: 0.75rem; /* 12px */
            border-radius: 0.5rem; /* 8px */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        #layer-control label {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem; /* 8px */
            font-size: 0.875rem; /* 14px */
            color: #1f2937; /* gray-800 */
            cursor: pointer;
        }
        #layer-control label:last-child {
            margin-bottom: 0;
        }
        #layer-control input[type="checkbox"] {
            margin-right: 0.5rem; /* 8px */
            height: 1rem; /* 16px */
            width: 1rem; /* 16px */
            border-radius: 0.25rem; /* 4px */
            border-color: #9ca3af; /* gray-400 */
            color: #007BFF; /* blue-600 */
            cursor: pointer;
        }
         /* Ensure overlays are on top */
        .leaflet-pane {
             z-index: 10;
        }
        .leaflet-control-container {
            z-index: 1000;
        }
        /* Leaflet Popup Customization */
        .leaflet-popup-content-wrapper {
            border-radius: 0.5rem; /* 8px */
        }
        .leaflet-popup-content {
            margin: 12px 16px;
            font-size: 14px;
            line-height: 1.6;
            max-width: 280px; /* Ensure popup isn't too wide */
            box-sizing: border-box;
        }
        .popup-title {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 8px;
            color: #333;
        }
        .popup-row {
            margin-bottom: 4px;
        }
        .popup-label {
            font-weight: 600;
            color: #555;
        }
        .popup-list-item {
            display: block;
            margin-left: 1rem;
            text-indent: -1rem;
            padding-left: 1rem;
            margin-top: 4px;
        }
        /* Navigation Button Style */
        .navigate-btn {
            background-color: #007BFF;
            color: white;
            padding: 6px 12px;
            border-radius: 0.375rem; /* 6px */
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin-top: 12px;
            width: 100%;
            transition: background-color 0.2s;
            box-sizing: border-box; /* Ensure padding doesn't break layout */
        }
        .navigate-btn:hover {
            background-color: #0056b3;
        }

        /* Tooltip Navigation Button */
        .tooltip-navigate-btn {
             background-color: #f3f4f6; /* gray-100 */
             color: #1f2937; /* gray-800 */
             padding: 4px 8px;
             border-radius: 0.25rem; /* 4px */
             border: 1px solid #d1d5db; /* gray-300 */
             cursor: pointer;
             font-size: 12px;
             font-weight: 500;
             margin-top: 6px;
             display: inline-block;
        }
        .tooltip-navigate-btn:hover {
            background-color: #e5e7eb; /* gray-200 */
        }

        /* Leaflet Routing Machine Panel */
        .leaflet-routing-container {
            max-height: 400px;
            overflow-y: auto;
            background-color: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        /* Custom route panel styling */
        .custom-route-panel {
            position: absolute;
            top: 100px;
            right: 10px;
            z-index: 1000;
            max-width: 350px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 10px;
            font-family: Arial, sans-serif;
        }

        /* User location icon */
        .user-location-icon {
            background-color: #4CAF50;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
        }

        /* Navigation notification */
        .navigation-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            z-index: 2000;
            max-width: 90%;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: fadeIn 0.3s ease-in;
        }

        /* Turn restriction icon */
        .turn-restriction-icon {
            background-color: #ff4444;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 12px;
            border: 2px solid #ffffff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            cursor: pointer;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        .navigation-notification.fade-out {
            animation: fadeOut 0.3s ease-out forwards;
        }

        @keyframes fadeOut {
            from { opacity: 1; transform: translateX(-50%) translateY(0); }
            to { opacity: 0; transform: translateX(-50%) translateY(-20px); }
        }
    </style>
</head>
<body class="font-sans antialiased relative overflow-hidden">

    <!-- Language Switcher -->
    <div id="lang-switcher" class="absolute top-4 right-4 z-[1000] bg-white rounded-lg shadow-md p-1 flex space-x-1">
        <button data-lang="en_US" class="lang-btn px-3 py-1 text-sm font-medium rounded-md">EN</button>
        <button data-lang="zh_TW" class="lang-btn px-3 py-1 text-sm font-medium rounded-md">ç¹</button>
        <button data-lang="zh_CN" class="lang-btn px-3 py-1 text-sm font-medium rounded-md">ç®€</button>
    </div>

    <!-- Locate User Button -->
    <button id="locate-btn" class="absolute top-16 right-4 z-[1000] bg-white rounded-lg shadow-md p-2 flex items-center justify-center cursor-pointer hover:bg-gray-100" title="Find my location">
        <svg class="w-5 h-5 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <!-- Crosshairs icon -->
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12a3 3 0 116 0 3 3 0 01-6 0z"></path>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m-9-9h1m16 0h1"></path>
        </svg>
    </button>

    <!-- Layer Control -->
    <div id="layer-control" class="absolute">
        <label>
            <input type="checkbox" id="toggle-carparks" checked>
            <span id="label-carparks">Car Parks</span>
        </label>
        <label>
            <input type="checkbox" id="toggle-attractions">
            <span id="label-attractions">Park Attractions</span>
        </label>
        <label>
            <input type="checkbox" id="toggle-viewing-points">
            <span id="label-viewing-points">Viewing Points</span>
        </label>
        <label>
            <input type="checkbox" id="toggle-parking-meters">
            <span id="label-parking-meters">Parking Meters</span>
        </label>
        <label>
            <input type="checkbox" id="toggle-roundabouts">
            <span id="label-roundabouts">Roundabouts</span>
        </label>
    </div>

    <!-- Map Container -->
    <div id="map"></div>
    
    <!-- Loading Spinner -->
    <div id="loading-spinner" class="hidden absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center z-[5000]">
        <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-blue-500"></div>
    </div>
    
    <!-- Information Modal -->
    <div id="info-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[4000] p-4 transition-opacity duration-300">
        <div class="bg-white rounded-lg shadow-2xl w-full max-w-md max-h-[90vh] overflow-y-auto">
            <!-- Modal Header -->
            <div class="flex justify-between items-center p-4 border-b">
                <h2 id="modal-title" class="text-xl font-bold text-gray-800">Car Park Details</h2>
                <button id="close-modal-btn" class="text-gray-500 hover:text-gray-800 text-3xl">&times;</button>
            </div>
            
            <!-- Modal Content -->
            <div id="modal-content" class="p-6 space-y-4">
                <!-- Content will be injected by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        // --- State Management ---
        let currentLang = 'en_US'; // Default language
        let markerLayer = null; // To store and clear carpark markers
        let attractionsLayer = null; // To store and clear attraction markers
        let viewingPointsLayer = null; // To store and clear viewing point markers
        let parkingMetersLayer = null; // To store and clear parking meter markers
        let roundaboutsLayer = null; // To store and clear roundabout markers
        let allAttractionsData = null; // Cache for attractions data
        let allViewingPointsData = null; // Cache for viewing points data
        let allParkingMetersData = null; // Cache for parking meter location data
        let allRoundaboutsData = null; // Cache for roundabout data
        let parkingMeterStatusMap = new Map(); // Cache for parking meter status
        let turnRestrictionsLayer = null; // To store turn restriction markers
        let allTurnRestrictionsData = null; // Cache for turn restrictions data
        let moveEndTimer = null; // Debounce timer for map movement
        let userLocationMarker = null; // Marker for user's location
        let userLocationCircle = null; // Accuracy circle for user's location
        let routingControl = null; // To store the routing control
        let routePanel = null; // To store the route instructions panel
        let navigationMode = false; // Flag for navigation mode
        let positionWatchId = null; // ID for position watching
        let currentRoute = null; // Current route data
        let currentInstructionIndex = 0; // Current instruction being followed
        let navigationNotification = null; // Notification element for navigation
        let warnedTurnRestrictions = new Set(); // Track warned turn restrictions
        let warnedRoundabouts = new Set(); // Track warned roundabouts
        let routeTurnRestrictionsLayer = null; // Layer for turn restrictions along current route
        let routeTurnRestrictions = []; // Turn restrictions along current route
        let routeRoundabouts = []; // Roundabouts along current route

        // --- i18n Translation Object ---
        const i18n = {
            'en_US': {
                modalTitle: 'Car Park Details',
                address: 'Address',
                parkId: 'Park ID',
                status: 'Status',
                vacancy: 'Vacancy',
                vac_car: 'Vacancy (Car)',
                vac_moto: 'Vacancy (Motorcycle)',
                vac_lgv: 'Vacancy (LGV)',
                vac_hgv: 'Vacancy (HGV)',
                vac_coach: 'Vacancy (Coach)',
                price_car: 'Hourly Price (Car)',
                heightLimit: 'Height Limit',
                remarks: 'Remarks',
                notAvailable: 'N/A',
                noVacancyData: 'No vacancy data available',
                errorTitle: 'Error',
                errorBody: 'Could not load car park data. Please try again later.',
                toggleCarParks: 'Car Parks',
                toggleAttractions: 'Country Park Attractions',
                toggleViewingPoints: 'Viewing Points',
                toggleParkingMeters: 'Parking Meters',
                toggleRoundabouts: 'Roundabouts',
                attractionErrorBody: 'Could not load park attractions. Please try again later.',
                viewingPointErrorBody: 'Could not load viewing points. Please try again later.',
                parkingMeterErrorBody: 'Could not load parking meters for this area. Please try again later.',
                roundaboutErrorBody: 'Could not load roundabout data. Please try again later.',
                website: 'Website',
                countryPark: 'Country Park',
                street: 'Street',
                sectionOfStreet: 'Section',
                vehicleType: 'Vehicle Type',
                operatingPeriod: 'Operating Period',
                totalMeters: 'Total Meters',
                availableMeters: 'Available',
                occupiedMeters: 'Occupied',
                geolocationError: 'Geolocation error: Could not find your location.',
                userLocationPopup: 'You are within {accuracy} meters of this point.',
                navigate: 'Navigate (Directions)',
                openInMaps: 'Open in Google Maps',
                vehicle_A: 'Any Vehicles (other than Medium and Heavy Goods Vehicles, Buses, Motor Cycles and Pedal Cycles)',
                vehicle_C: 'Coaches',
                vehicle_G: 'Goods Vehicles',
                op_F: '08.00 am - 09.00 pm daily',
                op_N: '07.00 pm - Midnight daily',
                op_P: '08.00 am - 08.00 pm daily on Mondays to Saturdays (no parking on Sundays)',
                op_D: '08.00 am - Midnight on Mondays to Saturdays; 10.00 am - 10.00 pm on Sundays and public holidays',
                op_S: 'No parking on 08.00 am - 05.00 pm daily on Mondays to Fridays; 05.00 pm - Midnight daily on Mondays to Fridays; 08.00 am - Midnight daily on Saturdays; 10.00 am - 10.00 pm daily on Sundays and public holidays',
                op_H: '08:00 am - 08:00 pm daily',
                op_E: '07:00 am - 08:00 pm daily',
                op_Q: '08:00 am - 08:00 pm daily on Mondays to Saturdays; 10:00 am - 10:00 pm daily on Sundays and public holidays',
                op_J: '08:00 am - Midnight daily',
                op_A: '08:00 am - Midnight on Mondays to Saturdays (except Sundays and public holidays)',
                op_B: '08:00 am - 08:00 pm daily on Mondays to Saturdays (except Sundays and public holidays)',
                unknown: 'Unknown',
                roundaboutWarning: 'Roundabout ahead! Slow down and choose the correct lane.',
                roundaboutApproaching: 'Approaching roundabout. Slow down.'
            },
            'zh_TW': {
                modalTitle: 'åœè»Šå ´è©³æƒ…',
                address: 'åœ°å€',
                parkId: 'åœè»Šå ´ID',
                status: 'ç‹€æ…‹',
                vacancy: 'ç©ºä½',
                vac_car: 'ç©ºä½ (ç§å®¶è»Š)',
                vac_moto: 'ç©ºä½ (é›»å–®è»Š)',
                vac_lgv: 'ç©ºä½ (è¼•å‹è²¨è»Š)',
                vac_hgv: 'ç©ºä½ (é‡å‹è²¨è»Š)',
                vac_coach: 'ç©ºä½ (å·´å£«)',
                price_car: 'æ¯å°æ™‚æ”¶è²» (ç§å®¶è»Š)',
                heightLimit: 'é«˜åº¦é™åˆ¶',
                remarks: 'å‚™è¨»',
                notAvailable: 'æ²’æœ‰è³‡æ–™',
                noVacancyData: 'æ²’æœ‰ç©ºä½è³‡æ–™',
                errorTitle: 'éŒ¯èª¤',
                errorBody: 'ç„¡æ³•åŠ è¼‰åœè»Šå ´è³‡æ–™ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚',
                toggleCarParks: 'åœè»Šå ´',
                toggleAttractions: 'éƒŠé‡å…¬åœ’æ™¯é»',
                toggleViewingPoints: 'è§€æ™¯å°',
                toggleParkingMeters: 'å’ªéŒ¶æ³Šè»Šä½',
                toggleRoundabouts: 'è¿´æ—‹è™•',
                attractionErrorBody: 'ç„¡æ³•åŠ è¼‰éƒŠé‡å…¬åœ’æ™¯é»ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚',
                viewingPointErrorBody: 'ç„¡æ³•åŠ è¼‰è§€æ™¯å°è³‡æ–™ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚',
                parkingMeterErrorBody: 'ç„¡æ³•åŠ è¼‰æ­¤å€åŸŸçš„å’ªéŒ¶æ³Šè»Šä½ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚',
                roundaboutErrorBody: 'ç„¡æ³•åŠ è¼‰è¿´æ—‹è™•è³‡æ–™ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚',
                website: 'ç¶²ç«™',
                countryPark: 'éƒŠé‡å…¬åœ’',
                street: 'è¡—é“',
                sectionOfStreet: 'è·¯æ®µ',
                vehicleType: 'è»Šè¼›é¡åˆ¥',
                operatingPeriod: 'é‹ä½œæ™‚æ®µ',
                totalMeters: 'ç¸½è»Šä½æ•¸',
                availableMeters: 'ç©ºç½®',
                occupiedMeters: 'å·²ä½”ç”¨',
                geolocationError: 'å®šä½éŒ¯èª¤ï¼šç„¡æ³•æ‰¾åˆ°æ‚¨çš„ä½ç½®ã€‚',
                userLocationPopup: 'æ‚¨åœ¨æ­¤åœ°é» {accuracy} ç±³ç¯„åœå…§ã€‚',
                navigate: 'å°èˆª (è·¯ç·š)',
                openInMaps: 'åœ¨ Google åœ°åœ–ä¸­é–‹å•Ÿ',
                vehicle_A: 'ä»»ä½•è»Šè¼› (ä¸­å‹åŠé‡å‹è²¨è»Šã€å·´å£«ã€é›»å–®è»ŠåŠæ©Ÿå‹•ä¸‰è¼ªè»Šé™¤å¤–)',
                vehicle_C: 'é•·é€”æ±½è»Š',
                vehicle_G: 'è²¨è»Š',
                op_F: 'æ¯å¤©ä¸Šåˆ 8 é»è‡³æ™šä¸Š 9 é»',
                op_N: 'æ¯å¤© 07:00 - åˆå¤œ',
                op_P: 'é€±ä¸€è‡³é€±å…­æ¯å¤©ä¸Šåˆ 8:00 è‡³æ™šä¸Š 8:00ï¼ˆé€±æ—¥ç¦æ­¢åœè»Šï¼‰',
                op_D: 'é€±ä¸€è‡³é€±å…­ä¸Šåˆ 08:00 è‡³åˆå¤œï¼› é€±æ—¥å’Œå…¬çœ¾å‡æœŸä¸Šåˆ 10 é»è‡³æ™šä¸Š 10 é»',
                op_S: 'é€±ä¸€è‡³é€±äº”æ¯å¤©ä¸Šåˆ 8 é»è‡³ä¸‹åˆ 5 é»ç¦æ­¢åœè»Šï¼› ä¸‹åˆ 05:00 - é€±ä¸€è‡³é€±äº”æ¯å¤©åˆå¤œï¼› é€±å…­æ¯å¤©ä¸Šåˆ 8 é»è‡³åˆå¤œï¼› é€±æ—¥å’Œå…¬çœ¾å‡æœŸæ¯å¤©ä¸Šåˆ 10 é»è‡³æ™šä¸Š 10 é»',
                op_H: 'æ¯å¤©ä¸Šåˆ8æ™‚è‡³æ™šä¸Š8æ™‚',
                op_E: 'æ¯å¤©ä¸Šåˆ7æ™‚è‡³æ™šä¸Š8æ™‚',
                op_Q: 'é€¢æ˜ŸæœŸä¸€è‡³å…­ä¸Šåˆ8æ™‚è‡³æ™šä¸Š8æ™‚ï¼›æ˜ŸæœŸæ—¥åŠå…¬çœ¾å‡æœŸä¸Šåˆ10æ™‚è‡³æ™šä¸Š10æ™‚',
                op_J: 'æ¯å¤©ä¸Šåˆ8æ™‚è‡³åˆå¤œ',
                op_A: 'é€¢æ˜ŸæœŸä¸€è‡³å…­ä¸Šåˆ8æ™‚è‡³åˆå¤œ (æ˜ŸæœŸæ—¥åŠå…¬çœ¾å‡æœŸé™¤å¤–)',
                op_B: 'é€¢æ˜ŸæœŸä¸€è‡³å…­ä¸Šåˆ8æ™‚è‡³æ™šä¸Š8æ™‚ (æ˜ŸæœŸæ—¥åŠå…¬çœ¾å‡æœŸé™¤å¤–)',
                unknown: 'ä¸è©³',
                roundaboutWarning: 'å‰æ–¹æœ‰è¿´æ—‹è™•ï¼è«‹æ¸›é€Ÿä¸¦é¸æ“‡æ­£ç¢ºçš„è¡Œè»Šç·šã€‚',
                roundaboutApproaching: 'æ¥è¿‘è¿´æ—‹è™•ï¼Œè«‹æ¸›é€Ÿã€‚'
            },
            'zh_CN': {
                modalTitle: 'åœè½¦åœºè¯¦æƒ…',
                address: 'åœ°å€',
                parkId: 'åœè½¦åœºID',
                status: 'çŠ¶æ€',
                vacancy: 'ç©ºä½',
                vac_car: 'ç©ºä½ (ç§å®¶è½¦)',
                vac_moto: 'ç©ºä½ (æ‘©æ‰˜è½¦)',
                vac_lgv: 'ç©ºä½ (è½»å‹è´§è½¦)',
                vac_hgv: 'ç©ºä½ (é‡å‹è´§Vè½¦)',
                vac_coach: 'ç©ºä½ (å·´å£«)',
                price_car: 'æ¯å°æ—¶æ”¶è´¹ (ç§å®¶è½¦)',
                heightLimit: 'é«˜åº¦é™åˆ¶',
                remarks: 'å¤‡æ³¨',
                notAvailable: 'æ²¡æœ‰èµ„æ–™',
                noVacancyData: 'æ²¡æœ‰ç©ºä½èµ„æ–™',
                errorTitle: 'é”™è¯¯',
                errorBody: 'æ— æ³•åŠ è½½åœè½¦åœºèµ„æ–™ï¼Œè¯·ç¨åå†è¯•ã€‚',
                toggleCarParks: 'åœè½¦åœº',
                toggleAttractions: 'éƒŠé‡å…¬å›­æ™¯ç‚¹',
                toggleViewingPoints: 'è§‚æ™¯å°',
                toggleParkingMeters: 'å’ªè¡¨æ³Šè½¦ä½',
                toggleRoundabouts: 'å›æ—‹å¤„',
                attractionErrorBody: 'æ— æ³•åŠ è½½éƒŠé‡å…¬å›­æ™¯ç‚¹ï¼Œè¯·ç¨åå†è¯•ã€‚',
                viewingPointErrorBody: 'æ— æ³•åŠ è½½è§‚æ™¯å°èµ„æ–™ï¼Œè¯·ç¨åå†è¯•ã€‚',
                parkingMeterErrorBody: 'æ— æ³•åŠ è½½æ­¤åŒºåŸŸçš„å’ªè¡¨æ³Šè½¦ä½ï¼Œè¯·ç¨åå†è¯•ã€‚',
                roundaboutErrorBody: 'æ— æ³•åŠ è½½å›æ—‹å¤„èµ„æ–™ï¼Œè¯·ç¨åå†è¯•ã€‚',
                website: 'ç½‘ç«™',
                countryPark: 'éƒŠé‡å…¬å›­',
                street: 'è¡—é“',
                sectionOfStreet: 'è·¯æ®µ',
                vehicleType: 'è½¦è¾†ç±»åˆ«',
                operatingPeriod: 'è¿ä½œæ—¶æ®µ',
                totalMeters: 'æ€»è½¦ä½æ•°',
                availableMeters: 'ç©ºç½®',
                occupiedMeters: 'å·²å ç”¨',
                geolocationError: 'å®šä½é”™è¯¯ï¼šæ— æ³•æ‰¾åˆ°æ‚¨çš„ä½ç½®ã€‚',
                userLocationPopup: 'æ‚¨åœ¨æ­¤åœ°ç‚¹ {accuracy} ç±³èŒƒå›´å†…ã€‚',
                navigate: 'å¯¼èˆª (è·¯çº¿)',
                openInMaps: 'åœ¨ Google åœ°å›¾ä¸­æ‰“å¼€',
                vehicle_A: 'ä»»ä½•è½¦è¾† (ä¸­å‹åŠé‡å‹è´§è½¦ã€å·´å£«ã€æ‘©æ‰˜è½¦åŠæœºåŠ¨ä¸‰MLè½¦é™¤å¤–)',
                vehicle_C: 'é•¿é€”æ±½è½¦',
                vehicle_G: 'è´§è½¦',
                op_F: 'æ¯å¤©ä¸Šåˆ 8 ç‚¹è‡³æ™šä¸Š 9 ç‚¹',
                op_N: 'æ¯å¤© 07:00 - åˆå¤œ',
                op_P: 'å‘¨ä¸€è‡³å‘¨å…­æ¯å¤©ä¸Šåˆ 8:00 è‡³æ™šä¸Š 8:00ï¼ˆå‘¨æ—¥ç¦æ­¢åœè½¦ï¼‰',
                op_D: 'å‘¨ä¸€è‡³å‘¨å…­ä¸Šåˆ 08:00 è‡³åˆå¤œï¼› å‘¨æ—¥å’Œå…¬ä¼—å‡æœŸä¸Šåˆ 10 ç‚¹è‡³æ™šä¸Š 10 ç‚¹',
                op_S: 'å‘¨ä¸€è‡³å‘¨äº”æ¯å¤©ä¸Šåˆ 8 ç‚¹è‡³ä¸‹åˆ 5 ç‚¹ç¦æ­¢åœè½¦ï¼› ä¸‹åˆ 05:00 - å‘¨ä¸€è‡³å‘¨äº”æ¯å¤©åˆå¤œï¼› å‘¨å…­æ¯å¤©ä¸Šåˆ 8 ç‚¹è‡³åˆå¤œï¼› å‘¨æ—¥å’Œå…¬ä¼—å‡æœŸæ¯å¤©ä¸Šåˆ 10 ç‚¹è‡³æ™šä¸Š 10 ç‚¹',
                op_H: 'æ¯å¤©ä¸Šåˆ8æ—¶è‡³æ™šä¸Š8æ—¶',
                op_E: 'æ¯å¤©ä¸Šåˆ7æ—¶è‡³æ™šä¸Š8æ—¶',
                op_Q: 'é€¢æ˜ŸæœŸä¸€è‡³å…­ä¸Šåˆ8æ—¶è‡³æ™šä¸Š8æ—¶ï¼›æ˜ŸæœŸæ—¥åŠå…¬ä¼—å‡æœŸä¸Šåˆ10æ—¶è‡³æ™šä¸Š10æ—¶',
                op_J: 'æ¯å¤©ä¸Šåˆ8æ—¶è‡³åˆå¤œ',
                op_A: 'é€¢æ˜ŸæœŸä¸€è‡³å…­ä¸Šåˆ8æ—¶è‡³åˆå¤œ (æ˜ŸæœŸæ—¥åŠå…¬ä¼—å‡æœŸé™¤å¤–)',
                op_B: 'é€¢æ˜ŸæœŸä¸€è‡³å…­ä¸Šåˆ8æ—¶è‡³æ™šä¸Š8æ—¶ (æ˜ŸæœŸæ—¥åŠå…¬ä¼—å‡æœŸé™¤å¤–)',
                unknown: 'ä¸è¯¦',
                roundaboutWarning: 'å‰æ–¹æœ‰å›æ—‹å¤„ï¼è¯·å‡é€Ÿå¹¶é€‰æ‹©æ­£ç¡®çš„è½¦é“ã€‚',
                roundaboutApproaching: 'æ¥è¿‘å›æ—‹å¤„ï¼Œè¯·å‡é€Ÿã€‚'
            },
        };

        // --- Leaflet & Map Setup ---
        
        // Center map on Hong Kong
        const map = L.map('map').setView([22.3193, 114.1694], 12);
        
        // Initialize marker layers
        markerLayer = L.layerGroup().addTo(map); // Car parks, on by default
        attractionsLayer = L.layerGroup(); // Attractions, off by default
        viewingPointsLayer = L.layerGroup(); // Viewing Points, off by default
        parkingMetersLayer = L.layerGroup(); // Parking Meters, off by default
        roundaboutsLayer = L.layerGroup(); // Roundabouts, off by default
        turnRestrictionsLayer = L.layerGroup(); // Turn restrictions, off by default
        routeTurnRestrictionsLayer = L.layerGroup(); // Route-specific turn restrictions, only visible during navigation

        // Add OpenStreetMap tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);
        
        // --- API URLs ---
        const API_INFO_BASE_URL = 'https://api.data.gov.hk/v1/carpark-info-vacancy?data=info';
        const API_VACANCY_BASE_URL = 'https://api.data.gov.hk/v1/carpark-info-vacancy?data=vacancy';
        const API_ATTRACTIONS_URL = 'https://portal.csdi.gov.hk/server/services/common/afcd_rcd_1728896853370_57183/MapServer/WFSServer?service=wfs&request=GetFeature&typenames=Attractions_in_Country_Parks&outputFormat=geojson';
        const API_VIEWING_POINTS_URL = 'https://portal.csdi.gov.hk/server/services/common/afcd_rcd_1635142967951_6079/MapServer/WFSServer?service=wfs&request=GetFeature&typenames=Viewing_Point&outputFormat=geojson&maxFeatures=100';
        const API_PARKING_METERS_BASE_URL = 'https://portal.csdi.gov.hk/server/services/common/td_rcd_1638930345315_81787/MapServer/WFSServer?service=wfs&request=GetFeature&typenames=parkingspaces&outputFormat=geojson&srsName=EPSG:4326';
        const API_PARKING_METERS_STATUS_URL = 'https://resource.data.one.gov.hk/td/psiparkingspaces/occupancystatus/occupancystatus.csv';
        const API_TURN_RESTRICTIONS_URL = 'https://static.data.gov.hk/td/road-network-v2/TURN.kmz';
        const API_ROUNDABOUTS_URL = 'https://static.data.gov.hk/td/road-network-v2/ROUNDABOUT.kmz';

        // --- DOM Elements ---
        const loadingSpinner = document.getElementById('loading-spinner');
        const infoModal = document.getElementById('info-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalContent = document.getElementById('modal-content');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const langSwitcher = document.getElementById('lang-switcher');
        const langButtons = document.querySelectorAll('.lang-btn');
        const toggleCarparks = document.getElementById('toggle-carparks');
        const toggleAttractions = document.getElementById('toggle-attractions');
        const toggleViewingPoints = document.getElementById('toggle-viewing-points');
        const toggleParkingMeters = document.getElementById('toggle-parking-meters');
        const toggleRoundabouts = document.getElementById('toggle-roundabouts');
        const labelCarparks = document.getElementById('label-carparks');
        const labelAttractions = document.getElementById('label-attractions');
        const labelViewingPoints = document.getElementById('label-viewing-points');
        const labelParkingMeters = document.getElementById('label-parking-meters');
        const labelRoundabouts = document.getElementById('label-roundabouts');
        const locateBtn = document.getElementById('locate-btn');

        // --- Modal Controls ---
        closeModalBtn.addEventListener('click', () => {
            infoModal.classList.add('hidden');
        });
        
        infoModal.addEventListener('click', (e) => {
            if (e.target === infoModal) {
                infoModal.classList.add('hidden');
            }
        });

        // --- Language Switcher Controls ---
        function updateLangUI() {
            // Update buttons
            langButtons.forEach(btn => {
                if (btn.dataset.lang === currentLang) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            // Update layer control labels
            const t = i18n[currentLang];
            labelCarparks.textContent = t.toggleCarParks;
            labelAttractions.textContent = t.toggleAttractions;
            labelViewingPoints.textContent = t.toggleViewingPoints;
            labelParkingMeters.textContent = t.toggleParkingMeters;
            labelRoundabouts.textContent = t.toggleRoundabouts;
        }

        langSwitcher.addEventListener('click', (e) => {
            const target = e.target.closest('.lang-btn');
            if (!target) return;

            const newLang = target.dataset.lang;
            if (newLang === currentLang) return; // No change

            currentLang = newLang;
            updateLangUI(); // Update UI

            // Refetch/replot data
            loadCarparkData();
            plotAttractions(); // Re-plot attractions with new language tooltips
            plotViewingPoints(); // Re-plot viewing points with new language tooltips
            plotParkingMeters(); // Re-plot parking meters with new language popups
            plotRoundabouts(); // Re-plot roundabouts with new language popups
        });

        // --- Layer Toggle Controls ---
        toggleCarparks.addEventListener('change', (e) => {
            if (e.target.checked) {
                map.addLayer(markerLayer);
            } else {
                map.removeLayer(markerLayer);
            }
        });

        toggleAttractions.addEventListener('change', (e) => {
            if (e.target.checked) {
                map.addLayer(attractionsLayer);
                // Load data if it's not already cached
                if (!allAttractionsData) {
                    loadAttractionsData();
                }
            } else {
                map.removeLayer(attractionsLayer);
            }
        });

        toggleViewingPoints.addEventListener('change', (e) => {
            if (e.target.checked) {
                map.addLayer(viewingPointsLayer);
                // Load data if it's not already cached
                if (!allViewingPointsData) {
                    loadViewingPointsData();
                }
            } else {
                map.removeLayer(viewingPointsLayer);
            }
        });

        toggleParkingMeters.addEventListener('change', (e) => {
            if (e.target.checked) {
                map.addLayer(parkingMetersLayer);
                // Load data if it's not already cached
                if (!allParkingMetersData) {
                    loadParkingMetersData();
                }
            } else {
                map.removeLayer(parkingMetersLayer);
            }
        });

        toggleRoundabouts.addEventListener('change', (e) => {
            if (e.target.checked) {
                map.addLayer(roundaboutsLayer);
                // Load data if it's not already cached
                if (!allRoundaboutsData) {
                    loadRoundaboutsData();
                }
            } else {
                map.removeLayer(roundaboutsLayer);
            }
        });

        // --- Locate User Button ---
        locateBtn.addEventListener('click', () => {
            if (!navigator.geolocation) {
                alert(i18n[currentLang].geolocationError);
                return;
            }
            
            loadingSpinner.classList.remove('hidden');
            
            navigator.geolocation.getCurrentPosition(
                // Success callback
                (position) => {
                    loadingSpinner.classList.add('hidden');
                    const { latitude, longitude, accuracy } = position.coords;
                    
                    // Remove existing user location marker if any
                    if (userLocationMarker) {
                        map.removeLayer(userLocationMarker);
                    }
                    if (userLocationCircle) {
                        map.removeLayer(userLocationCircle);
                    }
                    
                    // Create a marker for user's location
                    userLocationMarker = L.marker([latitude, longitude], {
                        icon: L.divIcon({
                            className: 'user-location-icon',
                            html: 'ğŸ“',
                            iconSize: [20, 20],
                            iconAnchor: [10, 10]
                        })
                    }).addTo(map);
                    
                    // Create a circle to show accuracy
                    userLocationCircle = L.circle([latitude, longitude], {
                        radius: accuracy,
                        color: '#4CAF50',
                        fillColor: '#4CAF50',
                        fillOpacity: 0.2,
                        weight: 1
                    }).addTo(map);
                    
                    // Add popup to user location
                    userLocationMarker.bindPopup(
                        i18n[currentLang].userLocationPopup.replace('{accuracy}', Math.round(accuracy))
                    );
                    
                    // Center map on user's location
                    map.setView([latitude, longitude], 15);
                },
                // Error callback
                (error) => {
                    loadingSpinner.classList.add('hidden');
                    console.error('Geolocation error:', error);
                    alert(i18n[currentLang].geolocationError);
                },
                // Options
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 60000
                }
            );
        });

        // --- Data Loading Functions ---

        // Load Carpark Data
        async function loadCarparkData() {
            loadingSpinner.classList.remove('hidden');
            markerLayer.clearLayers(); // Clear existing markers

            try {
                // Fetch carpark info data
                const infoResponse = await fetch(API_INFO_BASE_URL);
                if (!infoResponse.ok) {
                    throw new Error(`HTTP error! status: ${infoResponse.status}`);
                }
                const infoData = await infoResponse.json();

                // Fetch carpark vacancy data
                const vacancyResponse = await fetch(API_VACANCY_BASE_URL);
                if (!vacancyResponse.ok) {
                    throw new Error(`HTTP error! status: ${vacancyResponse.status}`);
                }
                const vacancyData = await vacancyResponse.json();

                // Create a map of vacancy data by parkId for quick lookup
                const vacancyMap = new Map();
                vacancyData.results.forEach(park => {
                    vacancyMap.set(park.park_Id, park);
                });

                // Plot carparks on the map
                infoData.results.forEach(park => {
                    const vacancy = vacancyMap.get(park.park_Id);
                    plotCarparkMarker(park, vacancy);
                });

                loadingSpinner.classList.add('hidden');
            } catch (error) {
                console.error('Error loading carpark data:', error);
                loadingSpinner.classList.add('hidden');
                showModal(i18n[currentLang].errorTitle, i18n[currentLang].errorBody);
            }
        }

        // Load Attractions Data
        async function loadAttractionsData() {
            loadingSpinner.classList.remove('hidden');
            attractionsLayer.clearLayers();

            try {
                // If we already have the data cached, use it
                if (allAttractionsData) {
                    plotAttractions();
                    loadingSpinner.classList.add('hidden');
                    return;
                }

                const response = await fetch(API_ATTRACTIONS_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                allAttractionsData = data;

                plotAttractions();
                loadingSpinner.classList.add('hidden');
            } catch (error) {
                console.error('Error loading attractions data:', error);
                loadingSpinner.classList.add('hidden');
                showModal(i18n[currentLang].errorTitle, i18n[currentLang].attractionErrorBody);
            }
        }

        // Load Viewing Points Data
        async function loadViewingPointsData() {
            loadingSpinner.classList.remove('hidden');
            viewingPointsLayer.clearLayers();

            try {
                // If we already have the data cached, use it
                if (allViewingPointsData) {
                    plotViewingPoints();
                    loadingSpinner.classList.add('hidden');
                    return;
                }

                const response = await fetch(API_VIEWING_POINTS_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                allViewingPointsData = data;

                plotViewingPoints();
                loadingSpinner.classList.add('hidden');
            } catch (error) {
                console.error('Error loading viewing points data:', error);
                loadingSpinner.classList.add('hidden');
                showModal(i18n[currentLang].errorTitle, i18n[currentLang].viewingPointErrorBody);
            }
        }

        // Load Parking Meters Data
        async function loadParkingMetersData() {
            loadingSpinner.classList.remove('hidden');
            parkingMetersLayer.clearLayers();

            try {
                // If we already have the data cached, use it
                if (allParkingMetersData) {
                    plotParkingMeters();
                    loadingSpinner.classList.add('hidden');
                    return;
                }

                // Get current map bounds
                const bounds = map.getBounds();
                const bbox = `${bounds.getWest()},${bounds.getSouth()},${bounds.getEast()},${bounds.getNorth()}`;
                const url = `${API_PARKING_METERS_BASE_URL}&bbox=${bbox}`;

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                allParkingMetersData = data;

                // Also load parking meter status
                await loadParkingMeterStatus();

                plotParkingMeters();
                loadingSpinner.classList.add('hidden');
            } catch (error) {
                console.error('Error loading parking meters data:', error);
                loadingSpinner.classList.add('hidden');
                showModal(i18n[currentLang].errorTitle, i18n[currentLang].parkingMeterErrorBody);
            }
        }

        // Load Parking Meter Status
        async function loadParkingMeterStatus() {
            try {
                const response = await fetch(API_PARKING_METERS_STATUS_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvText = await response.text();
                
                // Parse CSV
                const lines = csvText.split('\n');
                const headers = lines[0].split(',');
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = line.split(',');
                    const status = {};
                    
                    headers.forEach((header, index) => {
                        status[header] = values[index];
                    });
                    
                    // Use spaceId as key
                    if (status.spaceId) {
                        parkingMeterStatusMap.set(status.spaceId, status);
                    }
                }
            } catch (error) {
                console.error('Error loading parking meter status:', error);
            }
        }

        // Load Roundabouts Data
        async function loadRoundaboutsData() {
            loadingSpinner.classList.remove('hidden');
            roundaboutsLayer.clearLayers();

            try {
                // If we already have the data cached, use it
                if (allRoundaboutsData) {
                    plotRoundabouts();
                    loadingSpinner.classList.add('hidden');
                    return;
                }

                // Fetch the KMZ file
                const response = await fetch(API_ROUNDABOUTS_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const kmzBlob = await response.blob();
                const kmzData = await readKMZFile(kmzBlob);
                allRoundaboutsData = kmzData;

                plotRoundabouts();
                loadingSpinner.classList.add('hidden');
            } catch (error) {
                console.error('Error loading roundabouts data:', error);
                loadingSpinner.classList.add('hidden');
                showModal(i18n[currentLang].errorTitle, i18n[currentLang].roundaboutErrorBody);
            }
        }

        // --- Data Plotting Functions ---

        // Plot Carpark Markers
        function plotCarparkMarker(park, vacancy) {
            // Skip if no coordinates
            if (!park.wgs84Lat || !park.wgs84Long) return;

            // Create custom icon
            const carparkIcon = L.divIcon({
                className: 'carpark-icon',
                html: 'P',
                iconSize: [28, 28],
                iconAnchor: [14, 14]
            });

            // Create marker
            const marker = L.marker([parseFloat(park.wgs84Lat), parseFloat(park.wgs84Long)], {
                icon: carparkIcon
            }).addTo(markerLayer);

            // Prepare popup content
            const t = i18n[currentLang];
            let popupContent = `
                <div class="popup-title">${park.name || t.notAvailable}</div>
                <div class="popup-row"><span class="popup-label">${t.address}:</span> ${park.address || t.notAvailable}</div>
                <div class="popup-row"><span class="popup-label">${t.parkId}:</span> ${park.park_Id || t.notAvailable}</div>
            `;

            // Add vacancy information if available
            if (vacancy) {
                popupContent += `<div class="popup-row"><span class="popup-label">${t.status}:</span> ${vacancy.privateCar ? t.vacancy : t.noVacancyData}</div>`;
                
                if (vacancy.privateCar) {
                    popupContent += `
                        <div class="popup-row"><span class="popup-label">${t.vac_car}:</span> ${vacancy.privateCar.vacancy || 0}/${vacancy.privateCar.capacity || 0}</div>
                    `;
                }
                if (vacancy.motorCycle && vacancy.motorCycle.vacancy !== undefined) {
                    popupContent += `<div class="popup-row"><span class="popup-label">${t.vac_moto}:</span> ${vacancy.motorCycle.vacancy || 0}/${vacancy.motorCycle.capacity || 0}</div>`;
                }
                if (vacancy.LGV && vacancy.LGV.vacancy !== undefined) {
                    popupContent += `<div class="popup-row"><span class="popup-label">${t.vac_lgv}:</span> ${vacancy.LGV.vacancy || 0}/${vacancy.LGV.capacity || 0}</div>`;
                }
                if (vacancy.HGV && vacancy.HGV.vacancy !== undefined) {
                    popupContent += `<div class="popup-row"><span class="popup-label">${t.vac_hgv}:</span> ${vacancy.HGV.vacancy || 0}/${vacancy.HGV.capacity || 0}</div>`;
                }
                if (vacancy.coach && vacancy.coach.vacancy !== undefined) {
                    popupContent += `<div class="popup-row"><span class="popup-label">${t.vac_coach}:</span> ${vacancy.coach.vacancy || 0}/${vacancy.coach.capacity || 0}</div>`;
                }
            } else {
                popupContent += `<div class="popup-row"><span class="popup-label">${t.status}:</span> ${t.noVacancyData}</div>`;
            }

            // Add hourly price if available
            if (park.hourlyRate && park.hourlyRate.car) {
                popupContent += `<div class="popup-row"><span class="popup-label">${t.price_car}:</span> $${park.hourlyRate.car}</div>`;
            }

            // Add height limit if available
            if (park.heightLimit) {
                popupContent += `<div class="popup-row"><span class="popup-label">${t.heightLimit}:</span> ${park.heightLimit}m</div>`;
            }

            // Add remarks if available
            if (park.remarks) {
                popupContent += `<div class="popup-row"><span class="popup-label">${t.remarks}:</span> ${park.remarks}</div>`;
            }

            // Add navigation button
            popupContent += `<button class="navigate-btn" data-lat="${park.wgs84Lat}" data-lng="${park.wgs84Long}">${t.navigate}</button>`;

            // Bind popup to marker
            marker.bindPopup(popupContent);

            // Add click event for navigation
            marker.on('popupopen', () => {
                const navigateBtn = document.querySelector('.navigate-btn');
                if (navigateBtn) {
                    navigateBtn.addEventListener('click', (e) => {
                        const lat = e.target.dataset.lat;
                        const lng = e.target.dataset.lng;
                        startNavigation([parseFloat(lat), parseFloat(lng)]);
                    });
                }
            });
        }

        // Plot Attractions
        function plotAttractions() {
            if (!allAttractionsData) return;
            
            attractionsLayer.clearLayers();
            
            allAttractionsData.features.forEach(feature => {
                const coordinates = feature.geometry.coordinates;
                // GeoJSON uses [longitude, latitude] order
                const lat = coordinates[1];
                const lng = coordinates[0];
                
                // Create custom mountain icon
                const attractionIcon = L.divIcon({
                    className: 'mountain-icon',
                    html: `
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path d="M12 3L2 21h20L12 3zm0 3l7 15H5l7-15z"/>
                        </svg>
                    `,
                    iconSize: [28, 28],
                    iconAnchor: [14, 14]
                });
                
                const marker = L.marker([lat, lng], {
                    icon: attractionIcon
                }).addTo(attractionsLayer);
                
                // Prepare tooltip content
                const t = i18n[currentLang];
                const props = feature.properties;
                let tooltipContent = `<div class="font-bold">${props.name_eng || props.name_chi || t.notAvailable}</div>`;
                
                if (props.country_park) {
                    tooltipContent += `<div>${t.countryPark}: ${props.country_park}</div>`;
                }
                
                if (props.website) {
                    tooltipContent += `<div><a href="${props.website}" target="_blank" class="text-blue-600 hover:underline">${t.website}</a></div>`;
                }
                
                marker.bindTooltip(tooltipContent, {
                    direction: 'top',
                    offset: [0, -10],
                    className: 'leaflet-tooltip-custom'
                });
            });
        }

        // Plot Viewing Points
        function plotViewingPoints() {
            if (!allViewingPointsData) return;
            
            viewingPointsLayer.clearLayers();
            
            allViewingPointsData.features.forEach(feature => {
                const coordinates = feature.geometry.coordinates;
                // GeoJSON uses [longitude, latitude] order
                const lat = coordinates[1];
                const lng = coordinates[0];
                
                // Create custom viewer icon
                const viewingPointIcon = L.divIcon({
                    className: 'viewer-icon',
                    html: `
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                    `,
                    iconSize: [28, 28],
                    iconAnchor: [14, 14]
                });
                
                const marker = L.marker([lat, lng], {
                    icon: viewingPointIcon
                }).addTo(viewingPointsLayer);
                
                // Prepare tooltip content
                const t = i18n[currentLang];
                const props = feature.properties;
                let tooltipContent = `<div class="font-bold">${props.name_eng || props.name_chi || t.notAvailable}</div>`;
                
                if (props.country_park) {
                    tooltipContent += `<div>${t.countryPark}: ${props.country_park}</div>`;
                }
                
                marker.bindTooltip(tooltipContent, {
                    direction: 'top',
                    offset: [0, -10],
                    className: 'leaflet-tooltip-custom'
                });
            });
        }

        // Plot Parking Meters
        function plotParkingMeters() {
            if (!allParkingMetersData) return;
            
            parkingMetersLayer.clearLayers();
            
            allParkingMetersData.features.forEach(feature => {
                const coordinates = feature.geometry.coordinates;
                // GeoJSON uses [longitude, latitude] order
                const lat = coordinates[1];
                const lng = coordinates[0];
                
                // Create custom parking meter icon
                const parkingMeterIcon = L.divIcon({
                    className: 'parking-meter-icon',
                    html: `
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                            <path d="M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM9 18c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm0-3c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm3 3c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm0-3c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm3 3c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm0-3c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"/>
                        </svg>
                    `,
                    iconSize: [28, 28],
                    iconAnchor: [14, 14]
                });
                
                const marker = L.marker([lat, lng], {
                    icon: parkingMeterIcon
                }).addTo(parkingMetersLayer);
                
                // Prepare popup content
                const t = i18n[currentLang];
                const props = feature.properties;
                let popupContent = `
                    <div class="popup-title">${t.parkingMeters}</div>
                    <div class="popup-row"><span class="popup-label">${t.street}:</span> ${props.street || t.notAvailable}</div>
                    <div class="popup-row"><span class="popup-label">${t.sectionOfStreet}:</span> ${props.section || t.notAvailable}</div>
                `;
                
                // Vehicle type
                if (props.vehicleType) {
                    const vehicleTypeKey = `vehicle_${props.vehicleType}`;
                    popupContent += `<div class="popup-row"><span class="popup-label">${t.vehicleType}:</span> ${t[vehicleTypeKey] || props.vehicleType || t.unknown}</div>`;
                }
                
                // Operating period
                if (props.operatingPeriod) {
                    const opKey = `op_${props.operatingPeriod}`;
                    popupContent += `<div class="popup-row"><span class="popup-label">${t.operatingPeriod}:</span> ${t[opKey] || props.operatingPeriod || t.unknown}</div>`;
                }
                
                // Parking meter status
                if (props.spaceId) {
                    const status = parkingMeterStatusMap.get(props.spaceId);
                    if (status) {
                        popupContent += `
                            <div class="popup-row"><span class="popup-label">${t.totalMeters}:</span> ${status.totalSpace || 0}</div>
                            <div class="popup-row"><span class="popup-label">${t.availableMeters}:</span> ${status.availableSpace || 0}</div>
                            <div class="popup-row"><span class="popup-label">${t.occupiedMeters}:</span> ${status.occupiedSpace || 0}</div>
                        `;
                    }
                }
                
                // Add navigation button
                popupContent += `<button class="navigate-btn" data-lat="${lat}" data-lng="${lng}">${t.navigate}</button>`;
                
                marker.bindPopup(popupContent);
                
                // Add click event for navigation
                marker.on('popupopen', () => {
                    const navigateBtn = document.querySelector('.navigate-btn');
                    if (navigateBtn) {
                        navigateBtn.addEventListener('click', (e) => {
                            const lat = e.target.dataset.lat;
                            const lng = e.target.dataset.lng;
                            startNavigation([parseFloat(lat), parseFloat(lng)]);
                        });
                    }
                });
            });
        }

        // Plot Roundabouts
        function plotRoundabouts() {
            if (!allRoundaboutsData) return;
            
            roundaboutsLayer.clearLayers();
            
            allRoundaboutsData.features.forEach(feature => {
                const coordinates = feature.geometry.coordinates;
                // For point features, coordinates are [longitude, latitude]
                const lat = coordinates[1];
                const lng = coordinates[0];
                
                // Create custom roundabout icon
                const roundaboutIcon = L.divIcon({
                    className: 'roundabout-icon',
                    html: 'â†»',
                    iconSize: [28, 28],
                    iconAnchor: [14, 14]
                });
                
                const marker = L.marker([lat, lng], {
                    icon: roundaboutIcon
                }).addTo(roundaboutsLayer);
                
                // Prepare popup content
                const t = i18n[currentLang];
                const props = feature.properties;
                
                let popupContent = `
                    <div class="popup-title">${t.toggleRoundabouts}</div>
                    <div class="popup-row"><strong>${t.roundaboutWarning}</strong></div>
                `;
                
                // Add any additional properties from the roundabout data
                if (props && Object.keys(props).length > 0) {
                    popupContent += '<div class="popup-row"><em>Additional information:</em></div>';
                    for (const [key, value] of Object.entries(props)) {
                        if (value) {
                            popupContent += `<div class="popup-row"><span class="popup-label">${key}:</span> ${value}</div>`;
                        }
                    }
                }
                
                marker.bindPopup(popupContent);
            });
        }

        // --- KMZ File Processing ---
        async function readKMZFile(kmzBlob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    try {
                        const zip = new JSZip();
                        const contents = await zip.loadAsync(e.target.result);
                        
                        // Find the KML file in the KMZ
                        let kmlFile = null;
                        for (const filename in contents.files) {
                            if (filename.endsWith('.kml')) {
                                kmlFile = contents.files[filename];
                                break;
                            }
                        }
                        
                        if (!kmlFile) {
                            reject(new Error('No KML file found in KMZ'));
                            return;
                        }
                        
                        // Read the KML content
                        const kmlText = await kmlFile.async('text');
                        
                        // Parse KML to GeoJSON (simplified)
                        const parser = new DOMParser();
                        const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
                        
                        const features = [];
                        const placemarks = kmlDoc.getElementsByTagName('Placemark');
                        
                        for (const placemark of placemarks) {
                            const nameElement = placemark.getElementsByTagName('name')[0];
                            const name = nameElement ? nameElement.textContent : 'Unnamed';
                            
                            const pointElement = placemark.getElementsByTagName('Point')[0];
                            if (pointElement) {
                                const coordinatesElement = pointElement.getElementsByTagName('coordinates')[0];
                                if (coordinatesElement) {
                                    const [lng, lat, alt] = coordinatesElement.textContent.split(',').map(Number);
                                    
                                    // Extract properties
                                    const properties = { name };
                                    
                                    // Add any ExtendedData
                                    const extendedData = placemark.getElementsByTagName('ExtendedData')[0];
                                    if (extendedData) {
                                        const dataElements = extendedData.getElementsByTagName('Data');
                                        for (const dataEl of dataElements) {
                                            const key = dataEl.getAttribute('name');
                                            const valueEl = dataEl.getElementsByTagName('value')[0];
                                            if (key && valueEl) {
                                                properties[key] = valueEl.textContent;
                                            }
                                        }
                                    }
                                    
                                    features.push({
                                        type: 'Feature',
                                        geometry: {
                                            type: 'Point',
                                            coordinates: [lng, lat]
                                        },
                                        properties: properties
                                    });
                                }
                            }
                        }
                        
                        resolve({
                            type: 'FeatureCollection',
                            features: features
                        });
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(kmzBlob);
            });
        }

        // --- Navigation Functions ---

        // Start navigation to destination
        function startNavigation(destination) {
            // Check if we have user location
            if (!userLocationMarker) {
                alert('Please enable location services first by clicking the locate button.');
                return;
            }
            
            const userLatLng = userLocationMarker.getLatLng();
            
            // Remove existing routing control if any
            if (routingControl) {
                map.removeControl(routingControl);
            }
            
            // Remove existing route panel if any
            if (routePanel) {
                routePanel.remove();
            }
            
            // Create routing control
            routingControl = L.Routing.control({
                waypoints: [
                    L.latLng(userLatLng.lat, userLatLng.lng),
                    L.latLng(destination[0], destination[1])
                ],
                routeWhileDragging: false,
                showAlternatives: false,
                lineOptions: {
                    styles: [{ color: '#007BFF', weight: 5 }]
                },
                createMarker: function() { return null; }, // Don't create default markers
                addWaypoints: false, // Disable adding waypoints
                draggableWaypoints: false // Disable dragging waypoints
            }).addTo(map);
            
            // Create custom route panel
            routePanel = L.DomUtil.create('div', 'custom-route-panel');
            document.body.appendChild(routePanel);
            
            // Listen for route found event
            routingControl.on('routesfound', function(e) {
                const routes = e.routes;
                if (routes && routes.length > 0) {
                    currentRoute = routes[0];
                    currentInstructionIndex = 0;
                    
                    // Display route instructions
                    displayRouteInstructions(currentRoute);
                    
                    // Extract turn restrictions and roundabouts along the route
                    extractRouteHazards(currentRoute);
                    
                    // Start navigation mode
                    navigationMode = true;
                    
                    // Start watching user position
                    startWatchingPosition();
                    
                    // Show initial navigation notification
                    showNavigationNotification('Navigation started. Follow the route instructions.');
                }
            });
            
            // Close any open popups
            map.closePopup();
        }

        // Display route instructions
        function displayRouteInstructions(route) {
            if (!routePanel) return;
            
            const t = i18n[currentLang];
            let html = '<div class="font-bold text-lg mb-2">Route Instructions</div>';
            html += `<div class="text-sm mb-2">Total distance: ${(route.summary.totalDistance / 1000).toFixed(1)} km</div>`;
            html += `<div class="text-sm mb-4">Estimated time: ${Math.round(route.summary.totalTime / 60)} minutes</div>`;
            
            html += '<div class="max-h-60 overflow-y-auto">';
            route.instructions.forEach((instruction, index) => {
                const activeClass = index === 0 ? 'bg-blue-100' : '';
                html += `
                    <div class="p-2 border-b ${activeClass}">
                        <div class="font-medium">${instruction.text}</div>
                        <div class="text-xs text-gray-600">${(instruction.distance / 1000).toFixed(1)} km</div>
                    </div>
                `;
            });
            html += '</div>';
            
            // Add stop navigation button
            html += `<button id="stop-navigation" class="mt-4 w-full bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded">Stop Navigation</button>`;
            
            routePanel.innerHTML = html;
            
            // Add event listener for stop navigation button
            document.getElementById('stop-navigation').addEventListener('click', stopNavigation);
        }

        // Extract turn restrictions and roundabouts along the route
        function extractRouteHazards(route) {
            routeTurnRestrictions = [];
            routeRoundabouts = [];
            warnedTurnRestrictions.clear();
            warnedRoundabouts.clear();
            
            // Clear previous route turn restrictions
            routeTurnRestrictionsLayer.clearLayers();
            
            // For each coordinate in the route, check if it's near a turn restriction or roundabout
            route.coordinates.forEach(coord => {
                const latLng = L.latLng(coord.lat, coord.lng);
                
                // Check for nearby roundabouts
                if (allRoundaboutsData) {
                    allRoundaboutsData.features.forEach(roundabout => {
                        const roundaboutLatLng = L.latLng(
                            roundabout.geometry.coordinates[1],
                            roundabout.geometry.coordinates[0]
                        );
                        
                        const distance = latLng.distanceTo(roundaboutLatLng);
                        
                        // If within 200 meters of a roundabout, add to route hazards
                        if (distance < 200) {
                            const existing = routeRoundabouts.find(r => 
                                r.geometry.coordinates[0] === roundabout.geometry.coordinates[0] &&
                                r.geometry.coordinates[1] === roundabout.geometry.coordinates[1]
                            );
                            
                            if (!existing) {
                                routeRoundabouts.push(roundabout);
                                
                                // Add marker for this roundabout on the route
                                const marker = L.marker([roundabout.geometry.coordinates[1], roundabout.geometry.coordinates[0]], {
                                    icon: L.divIcon({
                                        className: 'roundabout-icon',
                                        html: 'â†»',
                                        iconSize: [24, 24],
                                        iconAnchor: [12, 12]
                                    })
                                }).addTo(routeTurnRestrictionsLayer);
                                
                                marker.bindPopup(i18n[currentLang].roundaboutWarning);
                            }
                        }
                    });
                }
            });
        }

        // Start watching user position during navigation
        function startWatchingPosition() {
            if (!navigator.geolocation) return;
            
            positionWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    const { latitude, longitude, accuracy } = position.coords;
                    
                    // Update user location marker
                    if (userLocationMarker) {
                        userLocationMarker.setLatLng([latitude, longitude]);
                    }
                    if (userLocationCircle) {
                        userLocationCircle.setLatLng([latitude, longitude]);
                        userLocationCircle.setRadius(accuracy);
                    }
                    
                    // Check if we're approaching any hazards
                    checkApproachingHazards([latitude, longitude]);
                    
                    // Update current instruction based on position
                    updateCurrentInstruction([latitude, longitude]);
                },
                (error) => {
                    console.error('Error watching position:', error);
                },
                {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: 3000
                }
            );
        }

        // Check if user is approaching any hazards (roundabouts)
        function checkApproachingHazards(userPosition) {
            const userLatLng = L.latLng(userPosition[0], userPosition[1]);
            const t = i18n[currentLang];
            
            // Check roundabouts
            routeRoundabouts.forEach(roundabout => {
                const roundaboutId = `${roundabout.geometry.coordinates[0]},${roundabout.geometry.coordinates[1]}`;
                
                if (!warnedRoundabouts.has(roundaboutId)) {
                    const roundaboutLatLng = L.latLng(
                        roundabout.geometry.coordinates[1],
                        roundabout.geometry.coordinates[0]
                    );
                    
                    const distance = userLatLng.distanceTo(roundaboutLatLng);
                    
                    // Warn if within 150 meters of a roundabout
                    if (distance < 150) {
                        showNavigationNotification(t.roundaboutApproaching);
                        warnedRoundabouts.add(roundaboutId);
                    }
                }
            });
        }

        // Update current instruction based on user position
        function updateCurrentInstruction(userPosition) {
            if (!currentRoute) return;
            
            const userLatLng = L.latLng(userPosition[0], userPosition[1]);
            let closestInstructionIndex = 0;
            let minDistance = Infinity;
            
            // Find the closest instruction to the user
            currentRoute.instructions.forEach((instruction, index) => {
                // Calculate distance to this instruction point
                const instructionLatLng = L.latLng(instruction.coordinate.lat, instruction.coordinate.lng);
                const distance = userLatLng.distanceTo(instructionLatLng);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestInstructionIndex = index;
                }
            });
            
            // Update current instruction if it's different
            if (closestInstructionIndex !== currentInstructionIndex) {
                currentInstructionIndex = closestInstructionIndex;
                
                // Highlight the current instruction in the panel
                const instructionElements = routePanel.querySelectorAll('.p-2');
                instructionElements.forEach((el, index) => {
                    if (index === currentInstructionIndex) {
                        el.classList.add('bg-blue-100');
                    } else {
                        el.classList.remove('bg-blue-100');
                    }
                });
                
                // Show notification for the current instruction if it's significant
                if (currentInstructionIndex < currentRoute.instructions.length) {
                    const currentInstruction = currentRoute.instructions[currentInstructionIndex];
                    
                    // Only show notifications for important maneuvers
                    if (currentInstruction.type.includes('Left') || 
                        currentInstruction.type.includes('Right') ||
                        currentInstruction.type.includes('Roundabout') ||
                        currentInstruction.type.includes('Start') ||
                        currentInstruction.type.includes('Destination')) {
                        
                        showNavigationNotification(currentInstruction.text);
                    }
                }
            }
        }

        // Show navigation notification
        function showNavigationNotification(message) {
            // Remove existing notification if any
            if (navigationNotification) {
                navigationNotification.remove();
            }
            
            // Create new notification
            navigationNotification = document.createElement('div');
            navigationNotification.className = 'navigation-notification';
            navigationNotification.textContent = message;
            
            document.body.appendChild(navigationNotification);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (navigationNotification) {
                    navigationNotification.classList.add('fade-out');
                    setTimeout(() => {
                        if (navigationNotification) {
                            navigationNotification.remove();
                            navigationNotification = null;
                        }
                    }, 300);
                }
            }, 5000);
        }

        // Stop navigation
        function stopNavigation() {
            navigationMode = false;
            
            // Stop watching position
            if (positionWatchId) {
                navigator.geolocation.clearWatch(positionWatchId);
                positionWatchId = null;
            }
            
            // Remove routing control
            if (routingControl) {
                map.removeControl(routingControl);
                routingControl = null;
            }
            
            // Remove route panel
            if (routePanel) {
                routePanel.remove();
                routePanel = null;
            }
            
            // Clear route data
            currentRoute = null;
            currentInstructionIndex = 0;
            
            // Clear route hazards layer
            routeTurnRestrictionsLayer.clearLayers();
            
            // Show notification
            showNavigationNotification('Navigation stopped.');
        }

        // --- Modal Display Function ---
        function showModal(title, body) {
            modalTitle.textContent = title;
            modalContent.innerHTML = `<p>${body}</p>`;
            infoModal.classList.remove('hidden');
        }

        // --- Map Move End Handler (for parking meters) ---
        map.on('moveend', function() {
            // Debounce to avoid too many requests
            if (moveEndTimer) {
                clearTimeout(moveEndTimer);
            }
            
            moveEndTimer = setTimeout(() => {
                // If parking meters layer is visible, reload data for current view
                if (toggleParkingMeters.checked) {
                    // Clear cached data to force reload
                    allParkingMetersData = null;
                    loadParkingMetersData();
                }
            }, 500);
        });

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            // Set initial language
            updateLangUI();
            
            // Load initial data (car parks)
            loadCarparkData();
            
            // Set up layer controls
            if (toggleCarparks.checked) {
                map.addLayer(markerLayer);
            }
            
            // Add route turn restrictions layer to map (initially empty)
            map.addLayer(routeTurnRestrictionsLayer);
        });
    </script>
</body>
</html>
