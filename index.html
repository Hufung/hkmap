<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hong Kong Finder</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet.js CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
     
    <!-- Leaflet.js JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>

    <!-- Leaflet Routing Machine CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    
    <!-- Leaflet Routing Machine JS -->
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

    <!-- JSZip for KMZ handling -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
     
    <style>
        /* Set map height */
        #map { 
            height: 100vh; 
            width: 100%;
            /* Ensure map is behind overlays */
            z-index: 10;
        }
        
        /* Custom Leaflet Icon Style for Car Parks */
        .carpark-icon {
            background-color: #007BFF;
            color: white;
            font-weight: bold;
            font-size: 14px;
            font-family: Arial, sans-serif;
            border: 2px solid #FFFFFF;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            cursor: pointer;
        }

        /* Custom Leaflet Icon Style for Attractions (Mountain SVG) */
        .mountain-icon {
            background-color: #22c55e; /* green-500 */
            border: 2px solid #FFFFFF;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            cursor: pointer;
        }
        .mountain-icon svg {
            width: 18px;
            height: 18px;
            fill: white;
        }

        /* Custom Leaflet Icon Style for Viewing Points (Viewer SVG) */
        .viewer-icon {
            background-color: #f59e0b; /* yellow-500 */
            border: 2px solid #FFFFFF;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            cursor: pointer;
        }
        .viewer-icon svg {
            width: 18px;
            height: 18px;
            fill: white;
        }
        
        /* Custom Leaflet Icon Style for Parking Meters (Car SVG) */
        .parking-meter-icon {
            background-color: #8b5cf6; /* purple-500 */
            border: 2px solid #FFFFFF;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            cursor: pointer;
        }
        .parking-meter-icon svg {
            width: 18px;
            height: 18px;
            fill: white;
        }

        /* Custom Leaflet Icon Style for Roundabouts */
        .roundabout-icon {
            background-color: #ff6b6b; /* red-400 */
            color: white;
            font-weight: bold;
            font-size: 14px;
            font-family: Arial, sans-serif;
            border: 2px solid #FFFFFF;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            cursor: pointer;
        }

        /* Language Switcher Styles */
        .lang-btn.active {
            background-color: #007BFF;
            color: white;
        }
        .lang-btn:not(.active) {
            background-color: #f3f4f6; /* Tailwind gray-100 */
            color: #374151; /* Tailwind gray-700 */
        }
        .lang-btn:not(.active):hover {
            background-color: #e5e7eb; /* Tailwind gray-200 */
        }

        /* Layer Control Styles */
        #layer-control {
            top: 1rem; /* 16px */
            left: 1rem; /* 16px */
            z-index: 1000;
            background-color: white;
            padding: 0.75rem; /* 12px */
            border-radius: 0.5rem; /* 8px */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        #layer-control label {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem; /* 8px */
            font-size: 0.875rem; /* 14px */
            color: #1f2937; /* gray-800 */
            cursor: pointer;
        }
        #layer-control label:last-child {
            margin-bottom: 0;
        }
        #layer-control input[type="checkbox"] {
            margin-right: 0.5rem; /* 8px */
            height: 1rem; /* 16px */
            width: 1rem; /* 16px */
            border-radius: 0.25rem; /* 4px */
            border-color: #9ca3af; /* gray-400 */
            color: #007BFF; /* blue-600 */
            cursor: pointer;
        }
         /* Ensure overlays are on top */
        .leaflet-pane {
             z-index: 10;
        }
        .leaflet-control-container {
            z-index: 1000;
        }
        /* Leaflet Popup Customization */
        .leaflet-popup-content-wrapper {
            border-radius: 0.5rem; /* 8px */
        }
        .leaflet-popup-content {
            margin: 12px 16px;
            font-size: 14px;
            line-height: 1.6;
            max-width: 280px; /* Ensure popup isn't too wide */
            box-sizing: border-box;
        }
        .popup-title {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 8px;
            color: #333;
        }
        .popup-row {
            margin-bottom: 4px;
        }
        .popup-label {
            font-weight: 600;
            color: #555;
        }
        .popup-list-item {
            display: block;
            margin-left: 1rem;
            text-indent: -1rem;
            padding-left: 1rem;
            margin-top: 4px;
        }
        /* Navigation Button Style */
        .navigate-btn {
            background-color: #007BFF;
            color: white;
            padding: 6px 12px;
            border-radius: 0.375rem; /* 6px */
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin-top: 12px;
            width: 100%;
            transition: background-color 0.2s;
            box-sizing: border-box; /* Ensure padding doesn't break layout */
        }
        .navigate-btn:hover {
            background-color: #0056b3;
        }

        /* Tooltip Navigation Button */
        .tooltip-navigate-btn {
             background-color: #f3f4f6; /* gray-100 */
             color: #1f2937; /* gray-800 */
             padding: 4px 8px;
             border-radius: 0.25rem; /* 4px */
             border: 1px solid #d1d5db; /* gray-300 */
             cursor: pointer;
             font-size: 12px;
             font-weight: 500;
             margin-top: 6px;
             display: inline-block;
        }
        .tooltip-navigate-btn:hover {
            background-color: #e5e7eb; /* gray-200 */
        }

        /* Leaflet Routing Machine Panel */
        .leaflet-routing-container {
            max-height: 400px;
            overflow-y: auto;
            background-color: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        /* Custom route panel styling */
        .custom-route-panel {
            position: absolute;
            top: 100px;
            right: 10px;
            z-index: 1000;
            max-width: 350px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 10px;
            font-family: Arial, sans-serif;
        }

        /* User location icon */
        .user-location-icon {
            background-color: #4CAF50;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
        }

        /* Navigation notification */
        .navigation-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            z-index: 2000;
            max-width: 90%;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: fadeIn 0.3s ease-in;
        }

        /* Turn restriction icon */
        .turn-restriction-icon {
            background-color: #ff4444;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 12px;
            border: 2px solid #ffffff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            cursor: pointer;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        .navigation-notification.fade-out {
            animation: fadeOut 0.3s ease-out forwards;
        }

        @keyframes fadeOut {
            from { opacity: 1; transform: translateX(-50%) translateY(0); }
            to { opacity: 0; transform: translateX(-50%) translateY(-20px); }
        }
    </style>
</head>
<body class="font-sans antialiased relative overflow-hidden">

    <!-- Language Switcher -->
    <div id="lang-switcher" class="absolute top-4 right-4 z-[1000] bg-white rounded-lg shadow-md p-1 flex space-x-1">
        <button data-lang="en_US" class="lang-btn px-3 py-1 text-sm font-medium rounded-md">EN</button>
        <button data-lang="zh_TW" class="lang-btn px-3 py-1 text-sm font-medium rounded-md">ç¹</button>
        <button data-lang="zh_CN" class="lang-btn px-3 py-1 text-sm font-medium rounded-md">ç®€</button>
    </div>

    <!-- Locate User Button -->
    <button id="locate-btn" class="absolute top-16 right-4 z-[1000] bg-white rounded-lg shadow-md p-2 flex items-center justify-center cursor-pointer hover:bg-gray-100" title="Find my location">
        <svg class="w-5 h-5 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <!-- Crosshairs icon -->
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12a3 3 0 116 0 3 3 0 01-6 0z"></path>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m-9-9h1m16 0h1"></path>
        </svg>
    </button>

    <!-- Layer Control -->
    <div id="layer-control" class="absolute">
        <label>
            <input type="checkbox" id="toggle-carparks" checked>
            <span id="label-carparks">Car Parks</span>
        </label>
        <label>
            <input type="checkbox" id="toggle-attractions">
            <span id="label-attractions">Park Attractions</span>
        </label>
        <label>
            <input type="checkbox" id="toggle-viewing-points">
            <span id="label-viewing-points">Viewing Points</span>
        </label>
        <label>
            <input type="checkbox" id="toggle-parking-meters">
            <span id="label-parking-meters">Parking Meters</span>
        </label>
        <label>
            <input type="checkbox" id="toggle-roundabouts">
            <span id="label-roundabouts">Roundabouts</span>
        </label>
    </div>

    <!-- Map Container -->
    <div id="map"></div>
    
    <!-- Loading Spinner -->
    <div id="loading-spinner" class="hidden absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center z-[5000]">
        <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-blue-500"></div>
    </div>
    
    <!-- Information Modal -->
    <div id="info-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[4000] p-4 transition-opacity duration-300">
        <div class="bg-white rounded-lg shadow-2xl w-full max-w-md max-h-[90vh] overflow-y-auto">
            <!-- Modal Header -->
            <div class="flex justify-between items-center p-4 border-b">
                <h2 id="modal-title" class="text-xl font-bold text-gray-800">Car Park Details</h2>
                <button id="close-modal-btn" class="text-gray-500 hover:text-gray-800 text-3xl">&times;</button>
            </div>
            
            <!-- Modal Content -->
            <div id="modal-content" class="p-6 space-y-4">
                <!-- Content will be injected by JavaScript -->
            </div>
        </div>
    </div>
<script>
// --- State Management ---
let currentLang = 'en_US'; // Default language
let markerLayer = null; // To store and clear carpark markers
let attractionsLayer = null; // To store and clear attraction markers
let viewingPointsLayer = null; // To store and clear viewing point markers
let parkingMetersLayer = null; // To store and clear parking meter markers
let roundaboutsLayer = null; // To store and clear roundabout markers
let allAttractionsData = null; // Cache for attractions data
let allViewingPointsData = null; // Cache for viewing points data
let allParkingMetersData = null; // Cache for parking meter location data
let allRoundaboutsData = null; // Cache for roundabout data
let parkingMeterStatusMap = new Map(); // Cache for parking meter status
let turnRestrictionsLayer = null; // To store turn restriction markers
let allTurnRestrictionsData = null; // Cache for turn restrictions data
let moveEndTimer = null; // Debounce timer for map movement
let userLocationMarker = null; // Marker for user's location
let userLocationCircle = null; // Accuracy circle for user's location
let routingControl = null; // To store the routing control
let routePanel = null; // To store the route instructions panel
let navigationMode = false; // Flag for navigation mode
let positionWatchId = null; // ID for position watching
let currentRoute = null; // Current route data
let currentInstructionIndex = 0; // Current instruction being followed
let navigationNotification = null; // Notification element for navigation
let warnedTurnRestrictions = new Set(); // Track warned turn restrictions
let warnedRoundabouts = new Set(); // Track warned roundabouts
let routeTurnRestrictionsLayer = null; // Layer for turn restrictions along current route
let routeTurnRestrictions = []; // Turn restrictions along current route
let routeRoundabouts = []; // Roundabouts along current route

// --- i18n Translation Object ---
const i18n = {
    'en_US': {
        modalTitle: 'Car Park Details',
        address: 'Address',
        parkId: 'Park ID',
        status: 'Status',
        vacancy: 'Vacancy',
        vac_car: 'Vacancy (Car)',
        vac_moto: 'Vacancy (Motorcycle)',
        vac_lgv: 'Vacancy (LGV)',
        vac_hgv: 'Vacancy (HGV)',
        vac_coach: 'Vacancy (Coach)',
        price_car: 'Hourly Price (Car)',
        heightLimit: 'Height Limit',
        remarks: 'Remarks',
        notAvailable: 'N/A',
        noVacancyData: 'No vacancy data available',
        errorTitle: 'Error',
        errorBody: 'Could not load car park data. Please try again later.',
        toggleCarParks: 'Car Parks',
        toggleAttractions: 'Country Park Attractions',
        toggleViewingPoints: 'Viewing Points',
        toggleParkingMeters: 'Parking Meters',
        toggleRoundabouts: 'Roundabouts',
        attractionErrorBody: 'Could not load park attractions. Please try again later.',
        viewingPointErrorBody: 'Could not load viewing points. Please try again later.',
        parkingMeterErrorBody: 'Could not load parking meters for this area. Please try again later.',
        roundaboutErrorBody: 'Could not load roundabout data. Please try again later.',
        website: 'Website',
        countryPark: 'Country Park',
        street: 'Street',
        sectionOfStreet: 'Section',
        vehicleType: 'Vehicle Type',
        operatingPeriod: 'Operating Period',
        totalMeters: 'Total Meters',
        availableMeters: 'Available',
        occupiedMeters: 'Occupied',
        geolocationError: 'Geolocation error: Could not find your location.',
        userLocationPopup: 'You are within {accuracy} meters of this point.',
        navigate: 'Navigate (Directions)',
        openInMaps: 'Open in Google Maps',
        vehicle_A: 'Any Vehicles (other than Medium and Heavy Goods Vehicles, Buses, Motor Cycles and Pedal Cycles)',
        vehicle_C: 'Coaches',
        vehicle_G: 'Goods Vehicles',
        op_F: '08.00 am - 09.00 pm daily',
        op_N: '07.00 pm - Midnight daily',
        op_P: '08.00 am - 08.00 pm daily on Mondays to Saturdays (no parking on Sundays)',
        op_D: '08.00 am - Midnight on Mondays to Saturdays; 10.00 am - 10.00 pm on Sundays and public holidays',
        op_S: 'No parking on 08.00 am - 05.00 pm daily on Mondays to Fridays; 05.00 pm - Midnight daily on Mondays to Fridays; 08.00 am - Midnight daily on Saturdays; 10.00 am - 10.00 pm daily on Sundays and public holidays',
        op_H: '08:00 am - 08:00 pm daily',
        op_E: '07:00 am - 08:00 pm daily',
        op_Q: '08:00 am - 08:00 pm daily on Mondays to Saturdays; 10:00 am - 10:00 pm daily on Sundays and public holidays',
        op_J: '08:00 am - Midnight daily',
        op_A: '08:00 am - Midnight on Mondays to Saturdays (except Sundays and public holidays)',
        op_B: '08:00 am - 08:00 pm daily on Mondays to Saturdays (except Sundays and public holidays)',
        unknown: 'Unknown',
        roundaboutWarning: 'Roundabout ahead! Slow down and choose the correct lane.',
        roundaboutApproaching: 'Approaching roundabout. Slow down.'
    },
    'zh_TW': {
        modalTitle: 'åœè»Šå ´è©³æƒ…',
        address: 'åœ°å€',
        parkId: 'åœè»Šå ´ID',
        status: 'ç‹€æ…‹',
        vacancy: 'ç©ºä½',
        vac_car: 'ç©ºä½ (ç§å®¶è»Š)',
        vac_moto: 'ç©ºä½ (é›»å–®è»Š)',
        vac_lgv: 'ç©ºä½ (è¼•å‹è²¨è»Š)',
        vac_hgv: 'ç©ºä½ (é‡å‹è²¨è»Š)',
        vac_coach: 'ç©ºä½ (å·´å£«)',
        price_car: 'æ¯å°æ™‚æ”¶è²» (ç§å®¶è»Š)',
        heightLimit: 'é«˜åº¦é™åˆ¶',
        remarks: 'å‚™è¨»',
        notAvailable: 'æ²’æœ‰è³‡æ–™',
        noVacancyData: 'æ²’æœ‰ç©ºä½è³‡æ–™',
        errorTitle: 'éŒ¯èª¤',
        errorBody: 'ç„¡æ³•åŠ è¼‰åœè»Šå ´è³‡æ–™ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚',
        toggleCarParks: 'åœè»Šå ´',
        toggleAttractions: 'éƒŠé‡å…¬åœ’æ™¯é»',
        toggleViewingPoints: 'è§€æ™¯å°',
        toggleParkingMeters: 'å’ªéŒ¶æ³Šè»Šä½',
        toggleRoundabouts: 'è¿´æ—‹è™•',
        attractionErrorBody: 'ç„¡æ³•åŠ è¼‰éƒŠé‡å…¬åœ’æ™¯é»ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚',
        viewingPointErrorBody: 'ç„¡æ³•åŠ è¼‰è§€æ™¯å°è³‡æ–™ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚',
        parkingMeterErrorBody: 'ç„¡æ³•åŠ è¼‰æ­¤å€åŸŸçš„å’ªéŒ¶æ³Šè»Šä½ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚',
        roundaboutErrorBody: 'ç„¡æ³•åŠ è¼‰è¿´æ—‹è™•è³‡æ–™ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚',
        website: 'ç¶²ç«™',
        countryPark: 'éƒŠé‡å…¬åœ’',
        street: 'è¡—é“',
        sectionOfStreet: 'è·¯æ®µ',
        vehicleType: 'è»Šè¼›é¡åˆ¥',
        operatingPeriod: 'é‹ä½œæ™‚æ®µ',
        totalMeters: 'ç¸½è»Šä½æ•¸',
        availableMeters: 'ç©ºç½®',
        occupiedMeters: 'å·²ä½”ç”¨',
        geolocationError: 'å®šä½éŒ¯èª¤ï¼šç„¡æ³•æ‰¾åˆ°æ‚¨çš„ä½ç½®ã€‚',
        userLocationPopup: 'æ‚¨åœ¨æ­¤åœ°é» {accuracy} ç±³ç¯„åœå…§ã€‚',
        navigate: 'å°èˆª (è·¯ç·š)',
        openInMaps: 'åœ¨ Google åœ°åœ–ä¸­é–‹å•Ÿ',
        vehicle_A: 'ä»»ä½•è»Šè¼› (ä¸­å‹åŠé‡å‹è²¨è»Šã€å·´å£«ã€é›»å–®è»ŠåŠæ©Ÿå‹•ä¸‰è¼ªè»Šé™¤å¤–)',
        vehicle_C: 'é•·é€”æ±½è»Š',
        vehicle_G: 'è²¨è»Š',
        op_F: 'æ¯å¤©ä¸Šåˆ 8 é»è‡³æ™šä¸Š 9 é»',
        op_N: 'æ¯å¤© 07:00 - åˆå¤œ',
        op_P: 'é€±ä¸€è‡³é€±å…­æ¯å¤©ä¸Šåˆ 8:00 è‡³æ™šä¸Š 8:00ï¼ˆé€±æ—¥ç¦æ­¢åœè»Šï¼‰',
        op_D: 'é€±ä¸€è‡³é€±å…­ä¸Šåˆ 08:00 è‡³åˆå¤œï¼› é€±æ—¥å’Œå…¬çœ¾å‡æœŸä¸Šåˆ 10 é»è‡³æ™šä¸Š 10 é»',
        op_S: 'é€±ä¸€è‡³é€±äº”æ¯å¤©ä¸Šåˆ 8 é»è‡³ä¸‹åˆ 5 é»ç¦æ­¢åœè»Šï¼› ä¸‹åˆ 05:00 - é€±ä¸€è‡³é€±äº”æ¯å¤©åˆå¤œï¼› é€±å…­æ¯å¤©ä¸Šåˆ 8 é»è‡³åˆå¤œï¼› é€±æ—¥å’Œå…¬çœ¾å‡æœŸæ¯å¤©ä¸Šåˆ 10 é»è‡³æ™šä¸Š 10 é»',
        op_H: 'æ¯å¤©ä¸Šåˆ8æ™‚è‡³æ™šä¸Š8æ™‚',
        op_E: 'æ¯å¤©ä¸Šåˆ7æ™‚è‡³æ™šä¸Š8æ™‚',
        op_Q: 'é€¢æ˜ŸæœŸä¸€è‡³å…­ä¸Šåˆ8æ™‚è‡³æ™šä¸Š8æ™‚ï¼›æ˜ŸæœŸæ—¥åŠå…¬çœ¾å‡æœŸä¸Šåˆ10æ™‚è‡³æ™šä¸Š10æ™‚',
        op_J: 'æ¯å¤©ä¸Šåˆ8æ™‚è‡³åˆå¤œ',
        op_A: 'é€¢æ˜ŸæœŸä¸€è‡³å…­ä¸Šåˆ8æ™‚è‡³åˆå¤œ (æ˜ŸæœŸæ—¥åŠå…¬çœ¾å‡æœŸé™¤å¤–)',
        op_B: 'é€¢æ˜ŸæœŸä¸€è‡³å…­ä¸Šåˆ8æ™‚è‡³æ™šä¸Š8æ™‚ (æ˜ŸæœŸæ—¥åŠå…¬çœ¾å‡æœŸé™¤å¤–)',
        unknown: 'ä¸è©³',
        roundaboutWarning: 'å‰æ–¹æœ‰è¿´æ—‹è™•ï¼è«‹æ¸›é€Ÿä¸¦é¸æ“‡æ­£ç¢ºçš„è¡Œè»Šç·šã€‚',
        roundaboutApproaching: 'æ¥è¿‘è¿´æ—‹è™•ï¼Œè«‹æ¸›é€Ÿã€‚'
    },
    'zh_CN': {
        modalTitle: 'åœè½¦åœºè¯¦æƒ…',
        address: 'åœ°å€',
        parkId: 'åœè½¦åœºID',
        status: 'çŠ¶æ€',
        vacancy: 'ç©ºä½',
        vac_car: 'ç©ºä½ (ç§å®¶è½¦)',
        vac_moto: 'ç©ºä½ (æ‘©æ‰˜è½¦)',
        vac_lgv: 'ç©ºä½ (è½»å‹è´§è½¦)',
        vac_hgv: 'ç©ºä½ (é‡å‹è´§Vè½¦)',
        vac_coach: 'ç©ºä½ (å·´å£«)',
        price_car: 'æ¯å°æ—¶æ”¶è´¹ (ç§å®¶è½¦)',
        heightLimit: 'é«˜åº¦é™åˆ¶',
        remarks: 'å¤‡æ³¨',
        notAvailable: 'æ²¡æœ‰èµ„æ–™',
        noVacancyData: 'æ²¡æœ‰ç©ºä½èµ„æ–™',
        errorTitle: 'é”™è¯¯',
        errorBody: 'æ— æ³•åŠ è½½åœè½¦åœºèµ„æ–™ï¼Œè¯·ç¨åå†è¯•ã€‚',
        toggleCarParks: 'åœè½¦åœº',
        toggleAttractions: 'éƒŠé‡å…¬å›­æ™¯ç‚¹',
        toggleViewingPoints: 'è§‚æ™¯å°',
        toggleParkingMeters: 'å’ªè¡¨æ³Šè½¦ä½',
        toggleRoundabouts: 'å›æ—‹å¤„',
        attractionErrorBody: 'æ— æ³•åŠ è½½éƒŠé‡å…¬å›­æ™¯ç‚¹ï¼Œè¯·ç¨åå†è¯•ã€‚',
        viewingPointErrorBody: 'æ— æ³•åŠ è½½è§‚æ™¯å°èµ„æ–™ï¼Œè¯·ç¨åå†è¯•ã€‚',
        parkingMeterErrorBody: 'æ— æ³•åŠ è½½æ­¤åŒºåŸŸçš„å’ªè¡¨æ³Šè½¦ä½ï¼Œè¯·ç¨åå†è¯•ã€‚',
        roundaboutErrorBody: 'æ— æ³•åŠ è½½å›æ—‹å¤„èµ„æ–™ï¼Œè¯·ç¨åå†è¯•ã€‚',
        website: 'ç½‘ç«™',
        countryPark: 'éƒŠé‡å…¬å›­',
        street: 'è¡—é“',
        sectionOfStreet: 'è·¯æ®µ',
        vehicleType: 'è½¦è¾†ç±»åˆ«',
        operatingPeriod: 'è¿ä½œæ—¶æ®µ',
        totalMeters: 'æ€»è½¦ä½æ•°',
        availableMeters: 'ç©ºç½®',
        occupiedMeters: 'å·²å ç”¨',
        geolocationError: 'å®šä½é”™è¯¯ï¼šæ— æ³•æ‰¾åˆ°æ‚¨çš„ä½ç½®ã€‚',
        userLocationPopup: 'æ‚¨åœ¨æ­¤åœ°ç‚¹ {accuracy} ç±³èŒƒå›´å†…ã€‚',
        navigate: 'å¯¼èˆª (è·¯çº¿)',
        openInMaps: 'åœ¨ Google åœ°å›¾ä¸­æ‰“å¼€',
        vehicle_A: 'ä»»ä½•è½¦è¾† (ä¸­å‹åŠé‡å‹è´§è½¦ã€å·´å£«ã€æ‘©æ‰˜è½¦åŠæœºåŠ¨ä¸‰MLè½¦é™¤å¤–)',
        vehicle_C: 'é•¿é€”æ±½è½¦',
        vehicle_G: 'è´§è½¦',
        op_F: 'æ¯å¤©ä¸Šåˆ 8 ç‚¹è‡³æ™šä¸Š 9 ç‚¹',
        op_N: 'æ¯å¤© 07:00 - åˆå¤œ',
        op_P: 'å‘¨ä¸€è‡³å‘¨å…­æ¯å¤©ä¸Šåˆ 8:00 è‡³æ™šä¸Š 8:00ï¼ˆå‘¨æ—¥ç¦æ­¢åœè½¦ï¼‰',
        op_D: 'å‘¨ä¸€è‡³å‘¨å…­ä¸Šåˆ 08:00 è‡³åˆå¤œï¼› å‘¨æ—¥å’Œå…¬ä¼—å‡æœŸä¸Šåˆ 10 ç‚¹è‡³æ™šä¸Š 10 ç‚¹',
        op_S: 'å‘¨ä¸€è‡³å‘¨äº”æ¯å¤©ä¸Šåˆ 8 ç‚¹è‡³ä¸‹åˆ 5 ç‚¹ç¦æ­¢åœè½¦ï¼› ä¸‹åˆ 05:00 - å‘¨ä¸€è‡³å‘¨äº”æ¯å¤©åˆå¤œï¼› å‘¨å…­æ¯å¤©ä¸Šåˆ 8 ç‚¹è‡³åˆå¤œï¼› å‘¨æ—¥å’Œå…¬ä¼—å‡æœŸæ¯å¤©ä¸Šåˆ 10 ç‚¹è‡³æ™šä¸Š 10 ç‚¹',
        op_H: 'æ¯å¤©ä¸Šåˆ8æ—¶è‡³æ™šä¸Š8æ—¶',
        op_E: 'æ¯å¤©ä¸Šåˆ7æ—¶è‡³æ™šä¸Š8æ—¶',
        op_Q: 'é€¢æ˜ŸæœŸä¸€è‡³å…­ä¸Šåˆ8æ—¶è‡³æ™šä¸Š8æ—¶ï¼›æ˜ŸæœŸæ—¥åŠå…¬ä¼—å‡æœŸä¸Šåˆ10æ—¶è‡³æ™šä¸Š10æ—¶',
        op_J: 'æ¯å¤©ä¸Šåˆ8æ—¶è‡³åˆå¤œ',
        op_A: 'é€¢æ˜ŸæœŸä¸€è‡³å…­ä¸Šåˆ8æ—¶è‡³åˆå¤œ (æ˜ŸæœŸæ—¥åŠå…¬ä¼—å‡æœŸé™¤å¤–)',
        op_B: 'é€¢æ˜ŸæœŸä¸€è‡³å…­ä¸Šåˆ8æ—¶è‡³æ™šä¸Š8æ—¶ (æ˜ŸæœŸæ—¥åŠå…¬ä¼—å‡æœŸé™¤å¤–)',
        unknown: 'ä¸è¯¦',
        roundaboutWarning: 'å‰æ–¹æœ‰å›æ—‹å¤„ï¼è¯·å‡é€Ÿå¹¶é€‰æ‹©æ­£ç¡®çš„è½¦é“ã€‚',
        roundaboutApproaching: 'æ¥è¿‘å›æ—‹å¤„ï¼Œè¯·å‡é€Ÿã€‚'
    },
};

// --- Leaflet & Map Setup ---

// Center map on Hong Kong
const map = L.map('map').setView([22.3193, 114.1694], 12);

// Initialize marker layers
markerLayer = L.layerGroup().addTo(map); // Car parks, on by default
attractionsLayer = L.layerGroup(); // Attractions, off by default
viewingPointsLayer = L.layerGroup(); // Viewing Points, off by default
parkingMetersLayer = L.layerGroup(); // Parking Meters, off by default
roundaboutsLayer = L.layerGroup(); // Roundabouts, off by default
turnRestrictionsLayer = L.layerGroup(); // Turn restrictions, off by default
routeTurnRestrictionsLayer = L.layerGroup(); // Route-specific turn restrictions, only visible during navigation

// Add OpenStreetMap tile layer
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
}).addTo(map);

// --- API URLs ---
const API_INFO_BASE_URL = 'https://api.data.gov.hk/v1/carpark-info-vacancy?data=info';
const API_VACANCY_BASE_URL = 'https://api.data.gov.hk/v1/carpark-info-vacancy?data=vacancy';
const API_ATTRACTIONS_URL = 'https://portal.csdi.gov.hk/server/services/common/afcd_rcd_1728896853370_57183/MapServer/WFSServer?service=wfs&request=GetFeature&typenames=Attractions_in_Country_Parks&outputFormat=geojson';
const API_VIEWING_POINTS_URL = 'https://portal.csdi.gov.hk/server/services/common/afcd_rcd_1635142967951_6079/MapServer/WFSServer?service=wfs&request=GetFeature&typenames=Viewing_Point&outputFormat=geojson&maxFeatures=100';
const API_PARKING_METERS_BASE_URL = 'https://portal.csdi.gov.hk/server/services/common/td_rcd_1638930345315_81787/MapServer/WFSServer?service=wfs&request=GetFeature&typenames=parkingspaces&outputFormat=geojson&srsName=EPSG:4326';
const API_PARKING_METERS_STATUS_URL = 'https://resource.data.one.gov.hk/td/psiparkingspaces/occupancystatus/occupancystatus.csv';
const API_TURN_RESTRICTIONS_URL = 'https://static.data.gov.hk/td/road-network-v2/TURN.kmz';
const API_ROUNDABOUTS_URL = 'https://static.data.gov.hk/td/road-network-v2/ROUNDABOUT.kmz';

// --- DOM Elements ---
const loadingSpinner = document.getElementById('loading-spinner');
const infoModal = document.getElementById('info-modal');
const modalTitle = document.getElementById('modal-title');
const modalContent = document.getElementById('modal-content');
const closeModalBtn = document.getElementById('close-modal-btn');
const langSwitcher = document.getElementById('lang-switcher');
const langButtons = document.querySelectorAll('.lang-btn');
const toggleCarparks = document.getElementById('toggle-carparks');
const toggleAttractions = document.getElementById('toggle-attractions');
const toggleViewingPoints = document.getElementById('toggle-viewing-points');
const toggleParkingMeters = document.getElementById('toggle-parking-meters');
const toggleRoundabouts = document.getElementById('toggle-roundabouts');
const labelCarparks = document.getElementById('label-carparks');
const labelAttractions = document.getElementById('label-attractions');
const labelViewingPoints = document.getElementById('label-viewing-points');
const labelParkingMeters = document.getElementById('label-parking-meters');
const labelRoundabouts = document.getElementById('label-roundabouts');
const locateBtn = document.getElementById('locate-btn');

// --- Modal Controls ---
closeModalBtn.addEventListener('click', () => {
    infoModal.classList.add('hidden');
});

infoModal.addEventListener('click', (e) => {
    if (e.target === infoModal) {
        infoModal.classList.add('hidden');
    }
});

// --- Language Switcher Controls ---
function updateLangUI() {
    // Update buttons
    langButtons.forEach(btn => {
        if (btn.dataset.lang === currentLang) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });
    // Update layer control labels
    const t = i18n[currentLang];
    labelCarparks.textContent = t.toggleCarParks;
    labelAttractions.textContent = t.toggleAttractions;
    labelViewingPoints.textContent = t.toggleViewingPoints;
    labelParkingMeters.textContent = t.toggleParkingMeters;
    labelRoundabouts.textContent = t.toggleRoundabouts;
}

langSwitcher.addEventListener('click', (e) => {
    const target = e.target.closest('.lang-btn');
    if (!target) return;

    const newLang = target.dataset.lang;
    if (newLang === currentLang) return; // No change

    currentLang = newLang;
    updateLangUI(); // Update UI

    // Refetch/replot data
    loadCarparkData();
    if (allAttractionsData) plotAttractions();
    if (allViewingPointsData) plotViewingPoints();
    if (allParkingMetersData) plotParkingMeters();
    if (allRoundaboutsData) plotRoundabouts();
});

// --- Layer Toggle Controls ---
toggleCarparks.addEventListener('change', (e) => {
    if (e.target.checked) {
        map.addLayer(markerLayer);
    } else {
        map.removeLayer(markerLayer);
    }
});

toggleAttractions.addEventListener('change', (e) => {
    if (e.target.checked) {
        map.addLayer(attractionsLayer);
        // Load data if it's not already cached
        if (!allAttractionsData) {
            loadAttractionsData();
        }
    } else {
        map.removeLayer(attractionsLayer);
    }
});

toggleViewingPoints.addEventListener('change', (e) => {
    if (e.target.checked) {
        map.addLayer(viewingPointsLayer);
        // Load data if it's not already cached
        if (!allViewingPointsData) {
            loadViewingPointsData();
        }
    } else {
        map.removeLayer(viewingPointsLayer);
    }
});

toggleParkingMeters.addEventListener('change', (e) => {
    if (e.target.checked) {
        map.addLayer(parkingMetersLayer);
        // Load data if it's not already cached
        if (!allParkingMetersData) {
            loadParkingMetersData();
        }
    } else {
        map.removeLayer(parkingMetersLayer);
    }
});

toggleRoundabouts.addEventListener('change', (e) => {
    if (e.target.checked) {
        map.addLayer(roundaboutsLayer);
        // Load data if it's not already cached
        if (!allRoundaboutsData) {
            loadRoundaboutsData();
        }
    } else {
        map.removeLayer(roundaboutsLayer);
    }
});

// --- Locate User Button ---
locateBtn.addEventListener('click', () => {
    if (!navigator.geolocation) {
        alert(i18n[currentLang].geolocationError);
        return;
    }
    
    loadingSpinner.classList.remove('hidden');
    
    navigator.geolocation.getCurrentPosition(
        // Success callback
        (position) => {
            loadingSpinner.classList.add('hidden');
            const { latitude, longitude, accuracy } = position.coords;
            
            // Remove existing user location marker if any
            if (userLocationMarker) {
                map.removeLayer(userLocationMarker);
            }
            if (userLocationCircle) {
                map.removeLayer(userLocationCircle);
            }
            
            // Create a marker for user's location
            userLocationMarker = L.marker([latitude, longitude], {
                icon: L.divIcon({
                    className: 'user-location-icon',
                    html: 'ğŸ“',
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                })
            }).addTo(map);
            
            // Create a circle to show accuracy
            userLocationCircle = L.circle([latitude, longitude], {
                radius: accuracy,
                color: '#4CAF50',
                fillColor: '#4CAF50',
                fillOpacity: 0.2,
                weight: 1
            }).addTo(map);
            
            // Add popup to user location
            userLocationMarker.bindPopup(
                i18n[currentLang].userLocationPopup.replace('{accuracy}', Math.round(accuracy))
            );
            
            // Center map on user's location
            map.setView([latitude, longitude], 15);
        },
        // Error callback
        (error) => {
            loadingSpinner.classList.add('hidden');
            console.error('Geolocation error:', error);
            alert(i18n[currentLang].geolocationError);
        },
        // Options
        {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 60000
        }
    );
});

// --- Custom Leaflet Icons ---
const createCarparkIcon = () => {
    return L.divIcon({
        className: 'carpark-icon',
        html: 'P',
        iconSize: [28, 28],
        iconAnchor: [14, 14]
    });
};

const createAttractionIcon = () => {
    // Simple mountain SVG
    const mountainSVG = `
        <svg viewBox="0 0 20 20">
            <path fill="currentColor" d="M10 1.25l-7.5 15h15l-7.5-15zm-2.19 10l-1.81 3.62h7.79l-1.81-3.62-1.09 2.18-1.09-2.18z"/>
        </svg>`;
    return L.divIcon({
        className: 'mountain-icon',
        html: mountainSVG,
        iconSize: [28, 28],
        iconAnchor: [14, 28] // Anchor at the bottom center
    });
};

const createViewingPointIcon = () => {
    // Simple viewer/eye SVG
    const viewerSVG = `
        <svg viewBox="0 0 24 24">
            <path fill="currentColor" d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zm0 13c-3.31 0-6-2.69-6-6s2.69-6 6-6s6 2.69 6 6s-2.69 6-6 6zm0-10c-2.21 0-4 1.79-4 4s1.79 4 4 4s4-1.79 4-4s-1.79-4-4-4z"/>
        </svg>`;
    return L.divIcon({
        className: 'viewer-icon',
        html: viewerSVG,
        iconSize: [28, 28],
        iconAnchor: [14, 28] // Anchor at the bottom center
    });
};

const createParkingMeterIcon = () => {
    // Simple car SVG
    const carSVG = `
        <svg viewBox="0 0 20 20">
            <path fill="currentColor" d="M18.9 6.2c-.4-.5-1-.8-1.7-.8H2.8c-.7 0-1.3.3-1.7.8c-.4.5-.6 1.1-.6 1.7v6.2c0 .6.2 1.2.6 1.7c.4.5 1 .8 1.7.8h.6c.4 0 .7.3.7.7v.7c0 .4.3.7.7.7h1.4c.4 0 .7-.3.7-.7v-.7c0-.4.3-.7.7-.7h7.2c.4 0 .7.3.7.7v.7c0 .4.3.7.7.7h1.4c.4 0 .7-.3.7-.7v-.7c0-.4.3-.7.7-.7h.6c.7 0 1.3-.3 1.7-.8c.4-.5.6-1.1.6-1.7V7.9c0-.6-.2-1.2-.6-1.7zM3.9 13.1c-.8 0-1.4-.6-1.4-1.4s.6-1.4 1.4-1.4s1.4.6 1.4 1.4s-.6 1.4-1.4 1.4zm12.2 0c-.8 0-1.4-.6-1.4-1.4s.6-1.4 1.4-1.4s1.4.6 1.4 1.4s-.6 1.4-1.4 1.4zM18 9H2V7.9c0-.1 0-.2.1-.3l.1-.1h15.6c.1 0 .2 0 .3.1l.1.3V9z"/>
        </svg>`;
    return L.divIcon({
        className: 'parking-meter-icon',
        html: carSVG,
        iconSize: [28, 28],
        iconAnchor: [14, 14]
    });
};

const createRoundaboutIcon = () => {
    return L.divIcon({
        className: 'roundabout-icon',
        html: 'â†»',
        iconSize: [28, 28],
        iconAnchor: [14, 14]
    });
};

const createTurnRestrictionIcon = () => {
    return L.divIcon({
        className: 'turn-restriction-icon',
        html: 'â†º',
        iconSize: [24, 24],
        iconAnchor: [12, 12]
    });
};

// --- Data Loading Functions ---

// Load Carpark Data - FIXED VERSION
async function loadCarparkData() {
    showLoading(true);
    
    if (markerLayer) {
        markerLayer.clearLayers();
    }
    
    const t = i18n[currentLang];
    const langParam = `&lang=${currentLang}`;

    try {
        const infoUrl = API_INFO_BASE_URL + langParam;
        console.log('Fetching car park info from:', infoUrl);
        
        const infoResponse = await fetch(infoUrl);
        if (!infoResponse.ok) throw new Error('Failed to fetch car park info.');
        const infoData = await infoResponse.json();
        const infoList = infoData.results || [];

        console.log('Car park info data:', infoList);

        if (infoList.length === 0) {
            console.warn('No car park info found.');
            showLoading(false);
            return; 
        }
        
        const parkIds = infoList.map(park => park.park_Id).join(',');
        const vacancyUrl = `${API_VACANCY_BASE_URL}&carparkIds=${parkIds}${langParam}`;
        console.log('Fetching vacancy data from:', vacancyUrl);
        
        const vacancyResponse = await fetch(vacancyUrl);
        let vacancyList = [];
        if (vacancyResponse.ok) {
            const vacancyData = await vacancyResponse.json();
            vacancyList = vacancyData.results || [];
            console.log('Vacancy data:', vacancyList);
        } else {
            console.error('Failed to fetch car park vacancy data.');
        }

        const combinedData = processData(infoList, vacancyList);
        plotCarparkMarkers(combinedData);

    } catch (error) {
        console.error('Error loading car park data:', error);
        modalContent.innerHTML = `<p class="text-red-500">${t.errorBody}</p>`;
        modalTitle.innerText = t.errorTitle;
        infoModal.classList.remove('hidden');
    } finally {
        showLoading(false);
    }
}

function processData(infoList, vacancyList) {
    const vacancyMap = new Map();
    for (const vacancy of vacancyList) {
        vacancyMap.set(vacancy.park_Id, vacancy);
    }
    return infoList.map(info => ({
        ...info,
        vacancyData: vacancyMap.get(info.park_Id) || null
    }));
}

// --- Map Plotting: Car Parks - FIXED VERSION ---
function plotCarparkMarkers(carparkList) {
    markerLayer.clearLayers();
    const icon = createCarparkIcon();
    
    console.log('Plotting car parks:', carparkList.length);
    
    carparkList.forEach(carpark => {
        // Try multiple possible coordinate properties
        let lat, lng;
        
        if (carpark.wgs84Lat && carpark.wgs84Long) {
            lat = parseFloat(carpark.wgs84Lat);
            lng = parseFloat(carpark.wgs84Long);
        } else if (carpark.latitude && carpark.longitude) {
            lat = parseFloat(carpark.latitude);
            lng = parseFloat(carpark.longitude);
        } else if (carpark.lat && carpark.lng) {
            lat = parseFloat(carpark.lat);
            lng = parseFloat(carpark.lng);
        } else {
            console.warn('No coordinates found for car park:', carpark.park_Id, carpark.name);
            return;
        }

        // Validate coordinates
        if (isNaN(lat) || isNaN(lng)) {
            console.warn('Invalid coordinates for car park:', carpark.park_Id, carpark.name, lat, lng);
            return;
        }

        console.log('Adding car park marker:', carpark.name, 'at', lat, lng);

        const marker = L.marker([lat, lng], { icon: icon })
            .addTo(markerLayer);
            
        marker.on('click', () => {
            showCarparkInfo(carpark);
        });
    });
    
    console.log('Total car parks plotted:', markerLayer.getLayers().length);
}

// --- Show Information Modal (for Car Parks) - FIXED VERSION ---
function showCarparkInfo(carpark) {
    const t = i18n[currentLang];
    modalTitle.innerText = carpark.name || t.modalTitle;
    
    const formatInfo = (label, value, unit = '') => {
        const displayValue = (value !== null && value !== undefined && value !== "") ? `${value}${unit}` : t.notAvailable;
        return `<div class="py-2 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-0">
                    <dt class="text-sm font-medium leading-6 text-gray-900">${label}</dt>
                    <dd class="mt-1 text-sm leading-6 text-gray-700 sm:col-span-2 sm:mt-0">${displayValue}</dd>
                </div>`;
    };

    let vacancyHtml = '';
    const vacancyData = carpark.vacancyData;
    if (vacancyData) {
        const vehicleTypeLabels = { 
            privateCar: t.vac_car, 
            motorCycle: t.vac_moto, 
            LGV: t.vac_lgv, 
            HGV: t.vac_hgv, 
            coach: t.vac_coach 
        };
        
        let hasVacancyInfo = false;
        for (const key in vehicleTypeLabels) {
            if (vacancyData[key]) {
                const vacancyInfo = vacancyData[key];
                let vacancyText = t.notAvailable;
                if (vacancyInfo && vacancyInfo.vacancy !== undefined) {
                    const capacity = vacancyInfo.capacity || '?';
                    vacancyText = `${vacancyInfo.vacancy}/${capacity}`;
                }
                vacancyHtml += formatInfo(vehicleTypeLabels[key], vacancyText);
                hasVacancyInfo = true;
            }
        }
        if (!hasVacancyInfo) vacancyHtml = formatInfo(t.vacancy, t.noVacancyData);
    } else {
        vacancyHtml = formatInfo(t.vacancy, t.noVacancyData);
    }
    
    let priceHtml = '';
    if (carpark.privateCar && carpark.privateCar.hourlyCharges) {
        const hourlyCharges = carpark.privateCar.hourlyCharges;
        if (Array.isArray(hourlyCharges) && hourlyCharges.length > 0) {
            hourlyCharges.forEach(charge => {
                const priceText = charge.price !== undefined ? `$${charge.price} / hour` : t.notAvailable;
                const remarkText = (charge.remark && charge.remark.trim() !== "") ? charge.remark : t.notAvailable; 
                const weekdays = charge.weekdays?.join(', ') || 'All Days'; 
                const period = (charge.periodStart && charge.periodEnd) ? `${charge.periodStart} - ${charge.periodEnd}` : 'All Hours';
                priceHtml += `
                    <div class="py-2 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-0">
                        <dt class="text-sm font-medium leading-6 text-gray-900">${t.price_car}</dt>
                        <dd class="mt-1 text-sm leading-6 text-gray-700 sm:col-span-2 sm:mt-0">
                            <p class="font-semibold">${priceText}</p>
                            <p class="text-xs text-gray-500">${weekdays} (${period})</p>
                            ${remarkText !== t.notAvailable ? `<p class="text-xs text-gray-500 mt-1">(${remarkText})</p>` : ''}
                        </dd>
                    </div>`;
            });
        }
    } else {
        priceHtml = formatInfo(t.price_car, t.notAvailable);
    }

    const heightLimit = carpark.heightLimits?.[0];
    const heightText = heightLimit ? `${heightLimit.height} m` : t.notAvailable;
    const remarkText = (heightLimit && heightLimit.remark && heightLimit.remark.trim() !== "") ? heightLimit.remark : t.notAvailable;
    const statusText = carpark.opening_status || t.notAvailable;
    const statusColor = (statusText === 'OPEN' || statusText === 'é–‹å•Ÿ' || statusText === 'å¼€å¯') ? 'text-green-600' : 'text-red-600';
    
    // Get coordinates for navigation
    let navLat, navLng;
    if (carpark.wgs84Lat && carpark.wgs84Long) {
        navLat = carpark.wgs84Lat;
        navLng = carpark.wgs84Long;
    } else if (carpark.latitude && carpark.longitude) {
        navLat = carpark.latitude;
        navLng = carpark.longitude;
    } else if (carpark.lat && carpark.lng) {
        navLat = carpark.lat;
        navLng = carpark.lng;
    }
    
    const navigateBtnHtml = navLat && navLng ? 
        `<button id="modal-navigate-btn" class="navigate-btn" data-lat="${navLat}" data-lon="${navLng}">${t.navigate}</button>` : '';

    modalContent.innerHTML = `
        <dl class="divide-y divide-gray-100">
            ${formatInfo(t.address, carpark.displayAddress || carpark.address)}
            ${formatInfo(t.parkId, carpark.park_Id)}
            <div class="py-2 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-0">
                <dt class="text-sm font-medium leading-6 text-gray-900">${t.status}</dt>
                <dd class="mt-1 text-sm font-bold leading-6 ${statusColor} sm:col-span-2 sm:mt-0">${statusText}</dd>
            </div>
            ${vacancyHtml}
            ${priceHtml}
            ${formatInfo(t.heightLimit, heightText)}
            ${formatInfo(t.remarks, remarkText)}
        </dl>
        ${navigateBtnHtml}
    `;
    
    const navBtn = document.getElementById('modal-navigate-btn');
    if (navBtn) {
        navBtn.addEventListener('click', () => {
            handleNavigationClick(navBtn.dataset.lat, navBtn.dataset.lon);
        });
    }

    infoModal.classList.remove('hidden');
}

// --- Data Fetching: Attractions ---
async function loadAttractionsData() {
    try {
        const response = await fetch(API_ATTRACTIONS_URL);
        if (!response.ok) throw new Error('Failed to fetch attractions data.');
        const data = await response.json();
        allAttractionsData = data.features || [];
        plotAttractions();
    } catch (error) {
        console.error('Error loading attractions data:', error);
        console.error(i18n[currentLang].attractionErrorBody);
    }
}

// --- Data Fetching: Viewing Points ---
async function loadViewingPointsData() {
    try {
        const response = await fetch(API_VIEWING_POINTS_URL);
        if (!response.ok) throw new Error('Failed to fetch viewing points data.');
        const data = await response.json();
        allViewingPointsData = data.features || [];
        plotViewingPoints();
    } catch (error) {
        console.error('Error loading viewing points data:', error);
        console.error(i18n[currentLang].viewingPointErrorBody);
    }
}

// --- Data Fetching: Parking Meters (Dynamic) ---
function parseCSVToMap(csvText) {
    const statusMap = new Map();
    const rows = csvText.split('\n');
    for (let i = 1; i < rows.length; i++) {
        const columns = rows[i].split(',');
        if (columns.length >= 3) {
            const parkingSpaceId = columns[0];
            const occupancyStatus = columns[2];
            if (parkingSpaceId && parkingSpaceId.trim() !== "") {
                statusMap.set(parkingSpaceId.trim(), occupancyStatus.trim());
            }
        }
    }
    return statusMap;
}

async function loadParkingMetersData() {
    if (!toggleParkingMeters.checked) return;

    const t = i18n[currentLang];
    try {
        const bounds = map.getBounds();
        const lowerCorner = `${bounds.getSouth()} ${bounds.getWest()}`;
        const upperCorner = `${bounds.getNorth()} ${bounds.getEast()}`;
        const filter = `<Filter><Intersects><PropertyName>SHAPE</PropertyName><gml:Envelope srsName='EPSG:4326'><gml:lowerCorner>${lowerCorner}</gml:lowerCorner><gml:upperCorner>${upperCorner}</gml:upperCorner></gml:Envelope></Intersects></Filter>`;
        const maxFeatures = 500; 
        const locationUrl = `${API_PARKING_METERS_BASE_URL}&maxFeatures=${maxFeatures}&filter=${encodeURIComponent(filter)}`;

        const [locationResponse, statusResponse] = await Promise.all([
            fetch(locationUrl),
            fetch(API_PARKING_METERS_STATUS_URL)
        ]);

        if (!locationResponse.ok) throw new Error('Failed to fetch parking meter location data.');
        if (!statusResponse.ok) throw new Error('Failed to fetch parking meter status data.');

        const locationData = await locationResponse.json();
        const statusText = await statusResponse.text();

        allParkingMetersData = locationData.features || [];
        parkingMeterStatusMap = parseCSVToMap(statusText);
        
        plotParkingMeters();

    } catch (error) {
        console.error('Error loading parking meters data:', error);
        console.error(t.parkingMeterErrorBody);
    }
}

// --- Data Fetching: Roundabouts (KMZ) ---
async function loadRoundaboutsData() {
    try {
        console.log('Loading roundabouts data from:', API_ROUNDABOUTS_URL);
        const response = await fetch(API_ROUNDABOUTS_URL);
        if (!response.ok) throw new Error('Failed to fetch roundabouts KMZ data.');

        const kmzBlob = await response.blob();
        const zip = await JSZip.loadAsync(kmzBlob);

        // Find the KML file in the KMZ
        const kmlFile = Object.keys(zip.files).find(fileName => fileName.endsWith('.kml'));
        if (!kmlFile) throw new Error('No KML file found in KMZ.');

        const kmlText = await zip.files[kmlFile].async('text');
        allRoundaboutsData = parseKMLToGeoJSON(kmlText);
        console.log('Roundabouts data loaded:', allRoundaboutsData.features.length, 'features');

        plotRoundabouts();

    } catch (error) {
        console.error('Error loading roundabouts data:', error);
    }
}

function parseKMLToGeoJSON(kmlText) {
    const parser = new DOMParser();
    const kmlDoc = parser.parseFromString(kmlText, 'text/xml');
    const placemarks = kmlDoc.querySelectorAll('Placemark');
    const features = [];

    placemarks.forEach(placemark => {
        const name = placemark.querySelector('name')?.textContent || '';
        const description = placemark.querySelector('description')?.textContent || '';
        const coordinates = placemark.querySelector('coordinates')?.textContent;

        if (coordinates) {
            const coords = coordinates.trim().split(',').map(c => parseFloat(c));
            if (coords.length >= 2) {
                features.push({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [coords[0], coords[1]]
                    },
                    properties: {
                        name: name,
                        description: description
                    }
                });
            }
        }
    });

    return {
        type: 'FeatureCollection',
        features: features
    };
}

// --- Map Plotting: Attractions ---
function plotAttractions() {
    if (attractionsLayer) attractionsLayer.clearLayers();
    if (!allAttractionsData) return;

    const icon = createAttractionIcon();
    const t = i18n[currentLang];
    const nameKey = (currentLang === 'en_US') ? 'NAME_EN' : 'NAME_CH';
    const locationKey = (currentLang === 'en_US') ? 'LOCATION_EN' : 'LOCATION_CH';

    allAttractionsData.forEach(feature => {
        const { coordinates } = feature.geometry;
        const { properties } = feature;
        
        if (coordinates && coordinates.length === 2) {
            const latLng = [coordinates[1], coordinates[0]]; 
            const name = properties[nameKey] || t.notAvailable;
            const location = properties[locationKey] || t.notAvailable;
            const website = properties['WEBSITE'];

            const navigateHtml = `<button class="tooltip-navigate-btn" data-lat="${latLng[0]}" data-lon="${latLng[1]}">${t.navigate}</button>`;
            let websiteHtml = '';
            if (website && website.trim() !== '') {
                websiteHtml = `<br><a href="${website}" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">${t.website}</a>`;
            }

            const tooltipContent = `
                <div class="p-1">
                    <strong class="text-base">${name}</strong>
                    <br>
                    <span class="text-sm">${location}</span>
                    ${websiteHtml}
                    <br>${navigateHtml}
                </div>
            `;

            const marker = L.marker(latLng, { icon: icon })
                .addTo(attractionsLayer);
                
            let closeTooltipTimer = null; 

            marker.bindTooltip(tooltipContent, { 
                permanent: false, 
                interactive: true 
            });

            const openTooltip = () => {
                if (closeTooltipTimer) {
                    clearTimeout(closeTooltipTimer);
                    closeTooltipTimer = null;
                }
                marker.openTooltip();
            };

            const startCloseTimer = () => {
                closeTooltipTimer = setTimeout(() => {
                    marker.closeTooltip();
                    closeTooltipTimer = null;
                }, 3000); 
            };

            marker.on('mouseover', openTooltip);
            marker.on('mouseout', startCloseTimer);

            marker.on('tooltipopen', function (e) {
                const tooltip = e.tooltip;
                if (tooltip) {
                    tooltip.getElement().addEventListener('mouseover', openTooltip);
                    tooltip.getElement().addEventListener('mouseout', startCloseTimer);
                    
                    // Add click listener for navigation button inside tooltip
                    const btn = tooltip.getElement().querySelector('.tooltip-navigate-btn');
                    if (btn && !btn.dataset.listenerAttached) {
                        btn.addEventListener('click', () => {
                            handleNavigationClick(btn.dataset.lat, btn.dataset.lon);
                        });
                        btn.dataset.listenerAttached = 'true';
                    }
                }
            });
        }
    });
}

// --- Map Plotting: Viewing Points ---
function plotViewingPoints() {
    if (viewingPointsLayer) viewingPointsLayer.clearLayers();
    if (!allViewingPointsData) return;

    const icon = createViewingPointIcon();
    const t = i18n[currentLang];
    const nameKey = (currentLang === 'en_US') ? 'Name_Eng' : 'Name_Chi';
    const addressKey = (currentLang === 'en_US') ? 'Address_En' : 'Address_Chi';
    const cpKey = (currentLang === 'en_US') ? 'CP_Eng' : 'CP_Chi';

    allViewingPointsData.forEach(feature => {
        const { coordinates } = feature.geometry;
        const { properties } = feature;

        if (coordinates && coordinates.length === 2) {
            const latLng = [coordinates[1], coordinates[0]]; 
            const name = properties[nameKey] || t.notAvailable;
            const countryPark = properties[cpKey] || t.notAvailable;
            const address = properties[addressKey] || t.notAvailable;

            const navigateHtml = `<button class="tooltip-navigate-btn" data-lat="${latLng[0]}" data-lon="${latLng[1]}">${t.navigate}</button>`;

            const tooltipContent = `
                <div class="p-1">
                    <strong class="text-base">${name}</strong>
                    <br>
                    <span class="text-sm">${t.countryPark}: ${countryPark}</span>
                    <br>
                    <span class="text-sm">${t.address}: ${address}</span>
                    <br>${navigateHtml}
                </div>
            `;

            const marker = L.marker(latLng, { icon: icon })
                .addTo(viewingPointsLayer);

            let closeTooltipTimer = null; 

            marker.bindTooltip(tooltipContent, {
                permanent: false, 
                interactive: true 
            });

            const openTooltip = () => {
                if (closeTooltipTimer) clearTimeout(closeTooltipTimer);
                closeTooltipTimer = null;
                marker.openTooltip();
            };

            const startCloseTimer = () => {
                closeTooltipTimer = setTimeout(() => {
                    marker.closeTooltip();
                    closeTooltipTimer = null;
                }, 3000);
            };

            marker.on('mouseover', openTooltip);
            marker.on('mouseout', startCloseTimer);

            marker.on('tooltipopen', function (e) {
                const tooltip = e.tooltip;
                if (tooltip) {
                    tooltip.getElement().addEventListener('mouseover', openTooltip);
                    tooltip.getElement().addEventListener('mouseout', startCloseTimer);

                    // Add click listener for navigation button inside tooltip
                    const btn = tooltip.getElement().querySelector('.tooltip-navigate-btn');
                    if (btn && !btn.dataset.listenerAttached) {
                        btn.addEventListener('click', () => {
                            handleNavigationClick(btn.dataset.lat, btn.dataset.lon);
                        });
                        btn.dataset.listenerAttached = 'true';
                    }
                }
            });
        }
    });
}

// --- Map Plotting: Parking Meters ---
function plotParkingMeters() {
    if (parkingMetersLayer) parkingMetersLayer.clearLayers();
    if (!allParkingMetersData || allParkingMetersData.length === 0) return;

    const icon = createParkingMeterIcon();
    const t = i18n[currentLang];

    const groupedMeters = new Map();
    const streetKey = (currentLang === 'en_US') ? 'Street' : (currentLang === 'zh_TW' ? 'Street_tc' : 'Street_sc');
    const sectionKey = (currentLang === 'en_US') ? 'SectionOfStreet' : (currentLang === 'zh_TW' ? 'SectionOfStreet_tc' : 'SectionOfStreet_sc');

    allParkingMetersData.forEach(feature => {
        const { properties, geometry } = feature;
        if (!geometry || !geometry.coordinates || geometry.coordinates.length !== 2) return;

        const section = properties[sectionKey] || t.notAvailable;
        const street = properties[streetKey] || t.notAvailable;
        const groupingKey = `${street} | ${section}`;

        if (!groupedMeters.has(groupingKey)) {
            const latLng = [geometry.coordinates[1], geometry.coordinates[0]];
            groupedMeters.set(groupingKey, {
                latLng: latLng,
                street: street,
                section: section,
                totalCount: 0,
                availableCount: 0,
                occupiedCount: 0,
                vehicleTypes: new Set(),
                opPeriods: new Set()
            });
        }

        const group = groupedMeters.get(groupingKey);
        group.totalCount++;

        const parkingSpaceId = properties.ParkingSpaceId;
        const status = parkingMeterStatusMap.get(parkingSpaceId);

        if (status === 'V') group.availableCount++;
        else if (status === 'O') group.occupiedCount++;

        if (properties.VehicleType) group.vehicleTypes.add(properties.VehicleType);
        if (properties.OperatingPeriod) group.opPeriods.add(properties.OperatingPeriod);
    });

    groupedMeters.forEach(group => {
        const vehicleTypesHtml = [...group.vehicleTypes]
            .map(code => `<span class="popup-list-item">&bull; ${decodeVehicleType(code, t)}</span>`)
            .join('');

        const opPeriodsHtml = [...group.opPeriods]
            .map(code => `<span class="popup-list-item">&bull; ${decodeOperatingPeriod(code, t)}</span>`)
            .join('');

        const navigateBtnHtml = `<button class="navigate-btn" data-lat="${group.latLng[0]}" data-lon="${group.latLng[1]}">${t.navigate}</button>`;

        const popupContent = `
            <div>
                <div class="popup-title">${group.street}</div>
                <div class="popup-row"><span class="popup-label">${t.sectionOfStreet}:</span> ${group.section}</div>
                <hr class="my-2">
                <div class="popup-row"><span class="popup-label">${t.totalMeters}:</span> ${group.totalCount}</div>
                <div class="popup-row"><span class="popup-label">${t.availableMeters}:</span> <span class="font-bold text-green-600">${group.availableCount}</span></div>
                <div class="popup-row"><span class="popup-label">${t.occupiedMeters}:</span> <span class="font-bold text-red-600">${group.occupiedCount}</span></div>
                <hr class="my-2">
                <div class="popup-row"><span class="popup-label">${t.vehicleType}:</span> ${vehicleTypesHtml || t.notAvailable}</div>
                <div class="popup-row"><span class="popup-label">${t.operatingPeriod}:</span> ${opPeriodsHtml || t.notAvailable}</div>
                ${navigateBtnHtml}
            </div>
        `;

        L.marker(group.latLng, { icon: icon })
            .addTo(parkingMetersLayer)
            .bindPopup(popupContent);
    });
}

// --- Map Plotting: Roundabouts ---
function plotRoundabouts() {
    if (roundaboutsLayer) roundaboutsLayer.clearLayers();
    if (!allRoundaboutsData || !allRoundaboutsData.features) return;

    const icon = createRoundaboutIcon();
    const t = i18n[currentLang];

    allRoundaboutsData.features.forEach(feature => {
        const { geometry, properties } = feature;
        if (!geometry || !geometry.coordinates || geometry.coordinates.length < 2) return;

        const latLng = [geometry.coordinates[1], geometry.coordinates[0]];
        const name = properties.name || 'Roundabout';
        const description = properties.description || '';

        const popupContent = `
            <div>
                <div class="popup-title">${t.toggleRoundabouts}</div>
                <div class="popup-row"><strong>${t.roundaboutWarning}</strong></div>
                ${name ? `<div class="popup-row">${name}</div>` : ''}
                ${description ? `<div class="popup-row">${description}</div>` : ''}
            </div>
        `;

        L.marker(latLng, { icon: icon })
            .addTo(roundaboutsLayer)
            .bindPopup(popupContent);
    });
}

// --- Data Decoding Helpers ---
function decodeVehicleType(code, t) {
    if (!code) return t.unknown;
    code = code.length > 1 ? code[code.length - 1] : code;
    switch(code) {
        case 'A': return t.vehicle_A;
        case 'C': return t.vehicle_C;
        case 'G': return t.vehicle_G;
        case 'L': return t.vehicle_L || code;
        case 'M': return t.vehicle_M || code;
        default: return code;
    }
}

function decodeOperatingPeriod(code, t) {
    if (!code) return t.unknown;
    code = code.length > 1 ? code[code.length - 1] : code;
     switch(code) {
        case 'F': return t.op_F;
        case 'N': return t.op_N;
        case 'P': return t.op_P;
        case 'D': return t.op_D;
        case 'S': return t.op_S;
        case 'H': return t.op_H;
        case 'E': return t.op_E;
        case 'Q': return t.op_Q;
        case 'J': return t.op_J;
        case 'A': return t.op_A;
        case 'B': return t.op_B;
        default: return code;
    }
}

// --- Navigation Helper ---
function handleNavigationClick(destLat, destLon) {
    const t = i18n[currentLang];
    const destination = L.latLng(destLat, destLon);

    // Close the car park information modal
    infoModal.classList.add('hidden');

    // Clear previous route
    if (routingControl) {
        map.removeControl(routingControl);
        routingControl = null;
    }

    // Create a custom route panel
    if (routePanel) {
        routePanel.remove();
        routePanel = null;
    }

    routePanel = L.DomUtil.create('div', 'custom-route-panel');
    document.body.appendChild(routePanel);

    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                // Got user location
                const origin = L.latLng(position.coords.latitude, position.coords.longitude);

                routingControl = L.Routing.control({
                    waypoints: [
                        origin,
                        destination
                    ],
                    routeWhileDragging: false,
                    showAlternatives: true,
                    altLineOptions: {
                        styles: [
                            {color: 'black', opacity: 0.15, weight: 12},
                            {color: 'white', opacity: 0.8, weight: 8},
                            {color: 'blue', opacity: 0.8, weight: 4}
                        ]
                    },
                    lineOptions: {
                        styles: [
                            {color: 'black', opacity: 0.15, weight: 12},
                            {color: 'white', opacity: 0.8, weight: 8},
                            {color: 'blue', opacity: 0.8, weight: 4}
                        ]
                    },
                    show: false,
                    addWaypoints: false,
                    draggableWaypoints: false,
                    fitSelectedRoutes: true,
                    createMarker: function(i, wp) {
                        if (i === 0) {
                            return L.marker(wp.latLng, {
                                icon: L.divIcon({
                                    className: 'user-location-icon',
                                    html: '<div style="background-color: #4CAF50; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-weight: bold;">S</div>',
                                    iconSize: [20, 20],
                                    iconAnchor: [10, 10]
                                })
                            }).bindPopup(t.userLocationPopup.replace('{accuracy}', '0'));
                        } else {
                            return L.marker(wp.latLng, {
                                icon: createCarparkIcon()
                            });
                        }
                    },
                    router: L.Routing.osrmv1({
                        serviceUrl: 'https://router.project-osrm.org/route/v1',
                        profile: 'driving',
                        language: currentLang === 'en_US' ? 'en' : (currentLang === 'zh_TW' ? 'zh-CN' : 'zh-CN')
                    })
                }).addTo(map);

                // Custom handling for route found
                routingControl.on('routesfound', function(e) {
                    const routes = e.routes;
                    currentRoute = routes[0];
                    currentInstructionIndex = 0;
                    const summary = routes[0].summary;

                    // Enter navigation mode
                    navigationMode = true;
                    console.log('Entered navigation mode');

                    // Load roundabouts data for navigation warnings
                    if (!allRoundaboutsData) {
                        loadRoundaboutsData().then(() => {
                            filterRoundaboutsAlongRoute(routes[0]);
                        });
                    } else {
                        filterRoundaboutsAlongRoute(routes[0]);
                    }

                    startNavigation();

                    // Display route information
                    const distance = (summary.totalDistance / 1000).toFixed(2);
                    const time = (summary.totalTime / 60).toFixed(1);

                    let routeOptions = '';
                    if (routes.length > 1) {
                        routeOptions = '<div style="margin-bottom: 10px;"><strong>Select Route:</strong><select id="route-selector" style="margin-left: 10px; padding: 4px; border: 1px solid #ccc; border-radius: 4px;">';
                        routes.forEach((route, index) => {
                            const routeDistance = (route.summary.totalDistance / 1000).toFixed(2);
                            const routeTime = (route.summary.totalTime / 60).toFixed(1);
                            routeOptions += `<option value="${index}">Route ${index + 1}: ${routeDistance} km, ${routeTime} min</option>`;
                        });
                        routeOptions += '</select></div>';
                    }

                    routePanel.innerHTML = `
                        <div style="padding: 10px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); max-width: 350px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h3 style="margin: 0; font-size: 18px; font-weight: bold;">${t.navigate}</h3>
                                <button id="close-route-btn" style="background: none; border: none; font-size: 18px; cursor: pointer;">Ã—</button>
                            </div>
                            ${routeOptions}
                            <div style="font-size: 14px; margin-bottom: 10px;">
                                <div><strong>Distance:</strong> ${distance} km</div>
                                <div><strong>Estimated Time:</strong> ${time} min</div>
                            </div>
                            <div style="max-height: 300px; overflow-y: auto;">
                                <ol style="padding-left: 20px; margin: 0;" id="route-instructions">
                                    ${routes[0].instructions.map(instruction =>
                                        `<li style="margin-bottom: 8px; font-size: 14px; line-height: 1.4;">${instruction.text}</li>`
                                    ).join('')}
                                </ol>
                            </div>
                            <button id="stop-nav-btn" style="margin-top: 10px; padding: 10px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%; font-size: 14px; font-weight: bold;">Stop Navigation</button>
                        </div>
                    `;

                    document.getElementById('close-route-btn').addEventListener('click', clearRoute);
                    document.getElementById('stop-nav-btn').addEventListener('click', stopNavigation);

                    const routeSelector = document.getElementById('route-selector');
                    if (routeSelector) {
                        routeSelector.addEventListener('change', function() {
                            const selectedRouteIndex = parseInt(this.value);
                            const selectedRoute = routes[selectedRouteIndex];
                            currentRoute = selectedRoute;
                            currentInstructionIndex = 0;
                            warnedRoundabouts.clear();

                            if (!allRoundaboutsData) {
                                loadRoundaboutsData().then(() => {
                                    filterRoundaboutsAlongRoute(selectedRoute);
                                });
                            } else {
                                filterRoundaboutsAlongRoute(selectedRoute);
                            }

                            const selectedDistance = (selectedRoute.summary.totalDistance / 1000).toFixed(2);
                            const selectedTime = (selectedRoute.summary.totalTime / 60).toFixed(1);

                            const distanceElement = routePanel.querySelector('div:nth-child(3) div:first-child');
                            const timeElement = routePanel.querySelector('div:nth-child(3) div:nth-child(2)');
                            distanceElement.innerHTML = `<strong>Distance:</strong> ${selectedDistance} km`;
                            timeElement.innerHTML = `<strong>Estimated Time:</strong> ${selectedTime} min`;

                            const instructionsElement = document.getElementById('route-instructions');
                            instructionsElement.innerHTML = selectedRoute.instructions.map(instruction =>
                                `<li style="margin-bottom: 8px; font-size: 14px; line-height: 1.4;">${instruction.text}</li>`
                            ).join('');

                            routingControl.route(selectedRouteIndex);
                        });
                    }
                });

                routingControl.on('routingerror', function(e) {
                    console.error('Routing error:', e.error);
                    routePanel.innerHTML = `
                        <div style="padding: 10px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); max-width: 300px;">
                            <h3 style="margin: 0 0 10px 0; font-size: 16px;">Routing Error</h3>
                            <p style="font-size: 14px; margin: 0;">Could not calculate route. Please try again.</p>
                            <button id="close-route-btn" style="margin-top: 10px; padding: 8px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%;">Close</button>
                        </div>
                    `;
                    document.getElementById('close-route-btn').addEventListener('click', clearRoute);
                });
            },
            (err) => {
                console.error(t.geolocationError, err.message);
                routePanel.innerHTML = `
                    <div style="padding: 10px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); max-width: 300px;">
                        <h3 style="margin: 0 0 10px 0; font-size: 16px;">Location Error</h3>
                        <p style="font-size: 14px; margin: 0;">${t.geolocationError}</p>
                        <button id="close-route-btn" style="margin-top: 10px; padding: 8px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%;">Close</button>
                    </div>
                `;
                document.getElementById('close-route-btn').addEventListener('click', clearRoute);
            }
        );
    } else {
        console.error(t.geolocationError, 'Geolocation is not supported by this browser.');
        routePanel.innerHTML = `
            <div style="padding: 10px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); max-width: 300px;">
                <h3 style="margin: 0 0 10px 0; font-size: 16px;">Browser Error</h3>
                <p style="font-size: 14px; margin: 0;">Geolocation is not supported by your browser.</p>
                <button id="close-route-btn" style="margin-top: 10px; padding: 8px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%;">Close</button>
            </div>
        `;
        document.getElementById('close-route-btn').addEventListener('click', clearRoute);
    }
}

function clearRoute() {
    stopNavigation();
    if (routingControl) {
        map.removeControl(routingControl);
        routingControl = null;
    }
    if (routePanel) {
        routePanel.remove();
        routePanel = null;
    }
}

// --- Navigation Mode Functions ---
function startNavigation() {
    if (!navigationMode || !currentRoute) return;

    if (navigator.geolocation) {
        positionWatchId = navigator.geolocation.watchPosition(
            handlePositionUpdate,
            (error) => console.error('Position watch error:', error),
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 5000
            }
        );
    }
}

function stopNavigation() {
    navigationMode = false;
    currentRoute = null;
    currentInstructionIndex = 0;
    warnedRoundabouts.clear();

    if (routeTurnRestrictionsLayer) {
        routeTurnRestrictionsLayer.clearLayers();
        if (map.hasLayer(routeTurnRestrictionsLayer)) {
            map.removeLayer(routeTurnRestrictionsLayer);
        }
    }
    routeRoundabouts = [];

    if (navigationNotification) {
        navigationNotification.remove();
        navigationNotification = null;
    }

    if (positionWatchId !== null) {
        navigator.geolocation.clearWatch(positionWatchId);
        positionWatchId = null;
    }
}

function filterRoundaboutsAlongRoute(route) {
    console.log('Starting filterRoundaboutsAlongRoute');
    if (!allRoundaboutsData || !allRoundaboutsData.features) {
        console.log('No roundabouts data available');
        return;
    }

    routeRoundabouts = [];

    const routeCoordinates = route.coordinates;
    const routeBuffer = 100;

    console.log('Filtering roundabouts for route with', routeCoordinates.length, 'coordinates');

    allRoundaboutsData.features.forEach((feature, index) => {
        const { geometry, properties } = feature;
        if (!geometry || !geometry.coordinates || geometry.coordinates.length < 2) {
            console.log('Skipping feature', index, 'due to invalid geometry');
            return;
        }

        const roundaboutLatLng = L.latLng(geometry.coordinates[1], geometry.coordinates[0]);

        let isNearRoute = false;
        let minDistance = Infinity;

        for (let i = 0; i < routeCoordinates.length - 1; i++) {
            const segmentStart = L.latLng(routeCoordinates[i][1], routeCoordinates[i][0]);
            const segmentEnd = L.latLng(routeCoordinates[i + 1][1], routeCoordinates[i + 1][0]);

            const distance = pointToLineDistance(roundaboutLatLng, segmentStart, segmentEnd);
            minDistance = Math.min(minDistance, distance);

            if (distance <= routeBuffer) {
                isNearRoute = true;
                console.log('Roundabout within buffer at segment', i, 'distance:', distance);
                break;
            }
        }

        if (isNearRoute) {
            routeRoundabouts.push(feature);
            console.log('Added roundabout:', properties.name, 'at distance:', minDistance, 'meters');

            const icon = createRoundaboutIcon();
            const popupContent = `
                <div>
                    <div class="popup-title">${properties.name || 'Roundabout'}</div>
                    <div class="popup-row">${i18n[currentLang].roundaboutWarning}</div>
                </div>
            `;

            const marker = L.marker(roundaboutLatLng, { icon: icon })
                .addTo(routeTurnRestrictionsLayer)
                .bindPopup(popupContent);
            console.log('Marker added to routeTurnRestrictionsLayer for roundabout:', properties.name);
        } else {
            console.log('Roundabout not near route:', properties.name, 'min distance:', minDistance);
        }
    });

    console.log('Total roundabouts along route:', routeRoundabouts.length);
}

function pointToLineDistance(point, lineStart, lineEnd) {
    const A = point.lat - lineStart.lat;
    const B = point.lng - lineStart.lng;
    const C = lineEnd.lat - lineStart.lat;
    const D = lineEnd.lng - lineStart.lng;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;

    let param = -1;
    if (lenSq !== 0) {
        param = dot / lenSq;
    }

    let xx, yy;
    if (param < 0) {
        xx = lineStart.lat;
        yy = lineStart.lng;
    } else if (param > 1) {
        xx = lineEnd.lat;
        yy = lineEnd.lng;
    } else {
        xx = lineStart.lat + param * C;
        yy = lineStart.lng + param * D;
    }

    const dx = point.lat - xx;
    const dy = point.lng - yy;

    return Math.sqrt(dx * dx + dy * dy) * 111320;
}

function handlePositionUpdate(position) {
    if (!navigationMode || !currentRoute) return;

    const userLatLng = L.latLng(position.coords.latitude, position.coords.longitude);
    const instructions = currentRoute.instructions;

    let nextInstruction = null;
    let nextInstructionIndex = currentInstructionIndex;

    for (let i = currentInstructionIndex; i < instructions.length; i++) {
        const instruction = instructions[i];
        const distanceToInstruction = userLatLng.distanceTo(instruction.latLng);

        if (distanceToInstruction < 50) {
            nextInstruction = instruction;
            nextInstructionIndex = i;
            break;
        }
    }

    if (nextInstruction && nextInstructionIndex > currentInstructionIndex) {
        currentInstructionIndex = nextInstructionIndex;
        showNavigationNotification(nextInstruction.text);
        speakInstruction(nextInstruction.text);
    }

    checkRoundaboutsProximity(userLatLng);

    const destination = currentRoute.coordinates[currentRoute.coordinates.length - 1];
    const distanceToDestination = userLatLng.distanceTo(L.latLng(destination[1], destination[0]));

    if (distanceToDestination < 20) {
        showNavigationNotification('You have arrived at your destination.');
        speakInstruction('You have arrived at your destination.');
        stopNavigation();
    }
}

function checkRoundaboutsProximity(userLatLng) {
    const t = i18n[currentLang];
    
    routeRoundabouts.forEach(feature => {
        const { geometry, properties } = feature;
        if (!geometry || !geometry.coordinates || geometry.coordinates.length < 2) return;

        const roundaboutLatLng = L.latLng(geometry.coordinates[1], geometry.coordinates[0]);
        const distance = userLatLng.distanceTo(roundaboutLatLng);

        const roundaboutId = `${geometry.coordinates[0]},${geometry.coordinates[1]}`;

        if (distance < 100 && !warnedRoundabouts.has(roundaboutId)) {
            showNavigationNotification(t.roundaboutApproaching);
            speakInstruction(t.roundaboutApproaching);
            warnedRoundabouts.add(roundaboutId);
        }
    });
}

function showNavigationNotification(message) {
    if (navigationNotification) {
        navigationNotification.remove();
    }

    navigationNotification = document.createElement('div');
    navigationNotification.className = 'navigation-notification';
    navigationNotification.textContent = message;
    document.body.appendChild(navigationNotification);

    setTimeout(() => {
        if (navigationNotification) {
            navigationNotification.classList.add('fade-out');
            setTimeout(() => {
                if (navigationNotification) {
                    navigationNotification.remove();
                    navigationNotification = null;
                }
            }, 300);
        }
    }, 5000);
}

function speakInstruction(text) {
    if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = currentLang === 'en_US' ? 'en-US' : (currentLang === 'zh_TW' ? 'zh-TW' : 'zh-CN');
        utterance.rate = 0.8;
        utterance.pitch = 1;
        utterance.volume = 0.8;

        window.speechSynthesis.speak(utterance);
    }
}

// --- Utility Functions ---
function showLoading(isLoading) {
    if (isLoading) {
        loadingSpinner.classList.remove('hidden');
    } else {
        loadingSpinner.classList.add('hidden');
    }
}

function handleMapMove() {
    clearTimeout(moveEndTimer);
    moveEndTimer = setTimeout(() => {
        if (toggleParkingMeters.checked) {
            loadParkingMetersData();
        }
    }, 500);
}

// --- Initial Load ---
updateLangUI();
loadCarparkData();

map.on('moveend', handleMapMove);

map.on('popupopen', (e) => {
    const popup = e.popup;
    const btn = popup.getElement().querySelector('.navigate-btn');
    if (btn) {
        if (!btn.dataset.listenerAttached) {
            btn.addEventListener('click', () => {
                handleNavigationClick(btn.dataset.lat, btn.dataset.lon);
            });
            btn.dataset.listenerAttached = 'true';
        }
    }
});
        </script>

</body>
</html>

